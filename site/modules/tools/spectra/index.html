
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.3.1, mkdocs-material-8.3.9">
    
    
      
        <title>Spectra - LBAE technical documentation</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.1d29e8d0.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.cbb835fc.min.css">
        
      
      
    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../assets/_mkdocstrings.css">
    
    <script>__md_scope=new URL("../../..",location),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="slate" data-md-color-primary="" data-md-color-accent="">
  
    
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#modules.tools.spectra" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="LBAE technical documentation" class="md-header__button md-logo" aria-label="LBAE technical documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            LBAE technical documentation
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Spectra
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="LBAE technical documentation" class="md-nav__button md-logo" aria-label="LBAE technical documentation" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    LBAE technical documentation
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Welcome page
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../main/" class="md-nav__link">
        main
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../app/" class="md-nav__link">
        app
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../index_py/" class="md-nav__link">
        index
      </a>
    </li>
  

    
      
      
      

  
  
    
  
  
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5" type="checkbox" id="__nav_5" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_5">
          Modules
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Modules" data-md-level="1">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          Modules
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../atlas_labels/" class="md-nav__link">
        atlas_labels
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../atlas/" class="md-nav__link">
        atlas
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../figures/" class="md-nav__link">
        figures
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../launch/" class="md-nav__link">
        launch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../maldi_data/" class="md-nav__link">
        maldi_data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../scRNAseq/" class="md-nav__link">
        scRNAseq
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../storage/" class="md-nav__link">
        storage
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_5_8" type="checkbox" id="__nav_5_8" checked>
      
      
      
      
        <label class="md-nav__link" for="__nav_5_8">
          Tools
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Tools" data-md-level="2">
        <label class="md-nav__title" for="__nav_5_8">
          <span class="md-nav__icon md-icon"></span>
          Tools
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../atlas/" class="md-nav__link">
        Atlas
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../image/" class="md-nav__link">
        Image
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../lookup_tables/" class="md-nav__link">
        Lookup tables
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../maldi_conversion/" class="md-nav__link">
        Maldi conversion
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../misc/" class="md-nav__link">
        Misc
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" data-md-toggle="toc" type="checkbox" id="__toc">
      
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          Spectra
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        Spectra
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra" class="md-nav__link">
    modules.tools.spectra
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.add_zeros_to_spectrum" class="md-nav__link">
    add_zeros_to_spectrum()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_avg_intensity_per_lipid" class="md-nav__link">
    compute_avg_intensity_per_lipid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_image_using_index_and_image_lookup" class="md-nav__link">
    compute_image_using_index_and_image_lookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_image_using_index_lookup" class="md-nav__link">
    compute_image_using_index_lookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_index_boundaries" class="md-nav__link">
    compute_index_boundaries()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_index_boundaries_nolookup" class="md-nav__link">
    compute_index_boundaries_nolookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_normalized_image_per_lipid" class="md-nav__link">
    compute_normalized_image_per_lipid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_normalized_spectra" class="md-nav__link">
    compute_normalized_spectra()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_spectrum_per_row_selection" class="md-nav__link">
    compute_spectrum_per_row_selection()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_standardization" class="md-nav__link">
    compute_standardization()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_thread_safe_function" class="md-nav__link">
    compute_thread_safe_function()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_zeros_extended_spectrum_per_pixel" class="md-nav__link">
    compute_zeros_extended_spectrum_per_pixel()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_array_to_fine_grained" class="md-nav__link">
    convert_array_to_fine_grained()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_coor_to_spectrum_idx" class="md-nav__link">
    convert_coor_to_spectrum_idx()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_spectrum_idx_to_coor" class="md-nav__link">
    convert_spectrum_idx_to_coor()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.get_list_row_indexes" class="md-nav__link">
    get_list_row_indexes()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.global_lipid_index_store" class="md-nav__link">
    global_lipid_index_store()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.reduce_resolution_sorted" class="md-nav__link">
    reduce_resolution_sorted()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.reduce_resolution_sorted_array_spectra" class="md-nav__link">
    reduce_resolution_sorted_array_spectra()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_idx_inf" class="md-nav__link">
    return_idx_inf()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_idx_sup" class="md-nav__link">
    return_idx_sup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_index_labels" class="md-nav__link">
    return_index_labels()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_spectrum_per_pixel" class="md-nav__link">
    return_spectrum_per_pixel()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.sample_rows_from_path" class="md-nav__link">
    sample_rows_from_path()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.strip_zeros" class="md-nav__link">
    strip_zeros()
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../volume/" class="md-nav__link">
        Volume
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
        <input class="md-nav__toggle md-toggle" data-md-toggle="__nav_6" type="checkbox" id="__nav_6" >
      
      
      
      
        <label class="md-nav__link" for="__nav_6">
          Pages
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" aria-label="Pages" data-md-level="1">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          Pages
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/home/" class="md-nav__link">
        home
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/sidebar/" class="md-nav__link">
        sidebar
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/load_slice/" class="md-nav__link">
        load_slice
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/lipid_selection/" class="md-nav__link">
        lipid_selection
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/region_analysis/" class="md-nav__link">
        region_analysis
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/threeD_exploration/" class="md-nav__link">
        threeD_exploration
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../pages/scRNAseq/" class="md-nav__link">
        scRNAseq
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra" class="md-nav__link">
    modules.tools.spectra
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.add_zeros_to_spectrum" class="md-nav__link">
    add_zeros_to_spectrum()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_avg_intensity_per_lipid" class="md-nav__link">
    compute_avg_intensity_per_lipid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_image_using_index_and_image_lookup" class="md-nav__link">
    compute_image_using_index_and_image_lookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_image_using_index_lookup" class="md-nav__link">
    compute_image_using_index_lookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_index_boundaries" class="md-nav__link">
    compute_index_boundaries()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_index_boundaries_nolookup" class="md-nav__link">
    compute_index_boundaries_nolookup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_normalized_image_per_lipid" class="md-nav__link">
    compute_normalized_image_per_lipid()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_normalized_spectra" class="md-nav__link">
    compute_normalized_spectra()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_spectrum_per_row_selection" class="md-nav__link">
    compute_spectrum_per_row_selection()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_standardization" class="md-nav__link">
    compute_standardization()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_thread_safe_function" class="md-nav__link">
    compute_thread_safe_function()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.compute_zeros_extended_spectrum_per_pixel" class="md-nav__link">
    compute_zeros_extended_spectrum_per_pixel()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_array_to_fine_grained" class="md-nav__link">
    convert_array_to_fine_grained()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_coor_to_spectrum_idx" class="md-nav__link">
    convert_coor_to_spectrum_idx()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.convert_spectrum_idx_to_coor" class="md-nav__link">
    convert_spectrum_idx_to_coor()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.get_list_row_indexes" class="md-nav__link">
    get_list_row_indexes()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.global_lipid_index_store" class="md-nav__link">
    global_lipid_index_store()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.reduce_resolution_sorted" class="md-nav__link">
    reduce_resolution_sorted()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.reduce_resolution_sorted_array_spectra" class="md-nav__link">
    reduce_resolution_sorted_array_spectra()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_idx_inf" class="md-nav__link">
    return_idx_inf()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_idx_sup" class="md-nav__link">
    return_idx_sup()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_index_labels" class="md-nav__link">
    return_index_labels()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.return_spectrum_per_pixel" class="md-nav__link">
    return_spectrum_per_pixel()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.sample_rows_from_path" class="md-nav__link">
    sample_rows_from_path()
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#modules.tools.spectra.strip_zeros" class="md-nav__link">
    strip_zeros()
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                


  <h1>Spectra</h1>

<div class="doc doc-object doc-module">


<a id="modules.tools.spectra"></a>
  <div class="doc doc-contents first">
  
      <p>In this module, functions used to handle the MALDI data (e.g. get all pixels values for a given 
lipid annotation, for of a given slice) are defined.</p>

  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.add_zeros_to_spectrum" class="doc doc-heading">
<code class="highlight language-python"><span class="n">add_zeros_to_spectrum</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">pad_individual_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function adds zeros in-between the peaks of the spectra contained in array_spectra (e.g.
to be able to plot them as scatterplotgl).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum data (m/z and
intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>pad_individual_peaks</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If true, pads the peaks individually, with a given
threshold distance between two m/z values to consider them as belonging to the same
peak. Else, it pads all single value in the spectrum with zeros. Defaults to False.</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>padding</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The m/z distance between a peak value and a zero for the padding.
Default to 10**-4.</p></td>
          <td>
                <code>10 ** -4</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>, <span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,m) containing the padded spectrum data (m/z
and intensity) and an array of shape (k,) containing the number of zeros added at each
index of array_spectra.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">728</span>
<span class="normal">729</span>
<span class="normal">730</span>
<span class="normal">731</span>
<span class="normal">732</span>
<span class="normal">733</span>
<span class="normal">734</span>
<span class="normal">735</span>
<span class="normal">736</span>
<span class="normal">737</span>
<span class="normal">738</span>
<span class="normal">739</span>
<span class="normal">740</span>
<span class="normal">741</span>
<span class="normal">742</span>
<span class="normal">743</span>
<span class="normal">744</span>
<span class="normal">745</span>
<span class="normal">746</span>
<span class="normal">747</span>
<span class="normal">748</span>
<span class="normal">749</span>
<span class="normal">750</span>
<span class="normal">751</span>
<span class="normal">752</span>
<span class="normal">753</span>
<span class="normal">754</span>
<span class="normal">755</span>
<span class="normal">756</span>
<span class="normal">757</span>
<span class="normal">758</span>
<span class="normal">759</span>
<span class="normal">760</span>
<span class="normal">761</span>
<span class="normal">762</span>
<span class="normal">763</span>
<span class="normal">764</span>
<span class="normal">765</span>
<span class="normal">766</span>
<span class="normal">767</span>
<span class="normal">768</span>
<span class="normal">769</span>
<span class="normal">770</span>
<span class="normal">771</span>
<span class="normal">772</span>
<span class="normal">773</span>
<span class="normal">774</span>
<span class="normal">775</span>
<span class="normal">776</span>
<span class="normal">777</span>
<span class="normal">778</span>
<span class="normal">779</span>
<span class="normal">780</span>
<span class="normal">781</span>
<span class="normal">782</span>
<span class="normal">783</span>
<span class="normal">784</span>
<span class="normal">785</span>
<span class="normal">786</span>
<span class="normal">787</span>
<span class="normal">788</span>
<span class="normal">789</span>
<span class="normal">790</span>
<span class="normal">791</span>
<span class="normal">792</span>
<span class="normal">793</span>
<span class="normal">794</span>
<span class="normal">795</span>
<span class="normal">796</span>
<span class="normal">797</span>
<span class="normal">798</span>
<span class="normal">799</span>
<span class="normal">800</span>
<span class="normal">801</span>
<span class="normal">802</span>
<span class="normal">803</span>
<span class="normal">804</span>
<span class="normal">805</span>
<span class="normal">806</span>
<span class="normal">807</span>
<span class="normal">808</span>
<span class="normal">809</span>
<span class="normal">810</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">add_zeros_to_spectrum</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">pad_individual_peaks</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function adds zeros in-between the peaks of the spectra contained in array_spectra (e.g.</span>
<span class="sd">    to be able to plot them as scatterplotgl).</span>

<span class="sd">    Args:</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum data (m/z and</span>
<span class="sd">            intensity) for each pixel.</span>
<span class="sd">        pad_individual_peaks (bool, optional): If true, pads the peaks individually, with a given</span>
<span class="sd">            threshold distance between two m/z values to consider them as belonging to the same</span>
<span class="sd">            peak. Else, it pads all single value in the spectrum with zeros. Defaults to False.</span>
<span class="sd">        padding (float, optional): The m/z distance between a peak value and a zero for the padding.</span>
<span class="sd">            Default to 10**-4.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (np.ndarray, np.ndarray): An array of shape (2,m) containing the padded spectrum data (m/z</span>
<span class="sd">            and intensity) and an array of shape (k,) containing the number of zeros added at each</span>
<span class="sd">            index of array_spectra.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For speed, allocate array of maximum size</span>
    <span class="n">new_array_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span>
    <span class="p">)</span>
    <span class="n">array_index_padding</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

    <span class="c1"># Either pad each peak individually</span>
    <span class="k">if</span> <span class="n">pad_individual_peaks</span><span class="p">:</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Loop over m/z values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>

            <span class="c1"># If there&#39;s a discontinuity between two peaks, pad with zeros</span>
            <span class="k">if</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">:</span>

                <span class="c1"># Add left peak</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

                <span class="c1"># Add zero to the right of left peak</span>
                <span class="n">pad</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Add zero to the left of right peak</span>
                <span class="n">pad</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Record that 2 zeros have been added between idx i and i+1</span>
                <span class="n">array_index_padding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

                <span class="c1"># Right peak added in the next loop iteration</span>

            <span class="c1"># Else, just store the values of array_spectra without padding</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># logging.info(&quot;two near peaks&quot;)</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
                <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">pad</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

        <span class="c1"># Add the last value of array_spectra</span>
        <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">new_array_spectra</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">pad</span><span class="p">],</span> <span class="n">array_index_padding</span>

    <span class="c1"># Or pad each m/z value individually</span>
    <span class="k">else</span><span class="p">:</span>

        <span class="c1"># Loop over m/z values</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># Store old array in a regular grid in the extended array</span>
            <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
            <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>

            <span class="c1"># Add zeros in the remaining slots</span>
            <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">padding</span>
            <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">padding</span>

            <span class="c1"># Record that 2 zeros have been added between idx i and i+1</span>
            <span class="n">array_index_padding</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="n">new_array_spectra</span><span class="p">,</span> <span class="n">array_index_padding</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_avg_intensity_per_lipid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_avg_intensity_per_lipid</span><span class="p">(</span><span class="n">l_intensity_with_lipids</span><span class="p">,</span> <span class="n">l_idx_labels</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function computes the average intensity of each annotated lipid (summing over peaks
coming from the same lipid) from a given spectrum.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>l_intensity_with_lipids</code></td>
          <td>
                <code>list(float</code>
          </td>
          <td><p>A list of peak intensities (where one lipid can</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>l_idx_labels</code></td>
          <td>
                <code>list(int</code>
          </td>
          <td><p>A list of lipid annotation, each lipid being annotated with a</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>list</code></td>          <td>
                <code>int), list(float</code>
          </td>
          <td><p>The first list provides the lipid indices, while the second provide</p></td>
        </tr>
        <tr>
<td></td>          <td>
          </td>
          <td><p>the lipid average intensities. Peaks corresponding to identical lipid have been averaged.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1285</span>
<span class="normal">1286</span>
<span class="normal">1287</span>
<span class="normal">1288</span>
<span class="normal">1289</span>
<span class="normal">1290</span>
<span class="normal">1291</span>
<span class="normal">1292</span>
<span class="normal">1293</span>
<span class="normal">1294</span>
<span class="normal">1295</span>
<span class="normal">1296</span>
<span class="normal">1297</span>
<span class="normal">1298</span>
<span class="normal">1299</span>
<span class="normal">1300</span>
<span class="normal">1301</span>
<span class="normal">1302</span>
<span class="normal">1303</span>
<span class="normal">1304</span>
<span class="normal">1305</span>
<span class="normal">1306</span>
<span class="normal">1307</span>
<span class="normal">1308</span>
<span class="normal">1309</span>
<span class="normal">1310</span>
<span class="normal">1311</span>
<span class="normal">1312</span>
<span class="normal">1313</span>
<span class="normal">1314</span>
<span class="normal">1315</span>
<span class="normal">1316</span>
<span class="normal">1317</span>
<span class="normal">1318</span>
<span class="normal">1319</span>
<span class="normal">1320</span>
<span class="normal">1321</span>
<span class="normal">1322</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_avg_intensity_per_lipid</span><span class="p">(</span><span class="n">l_intensity_with_lipids</span><span class="p">,</span> <span class="n">l_idx_labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function computes the average intensity of each annotated lipid (summing over peaks</span>
<span class="sd">    coming from the same lipid) from a given spectrum.</span>

<span class="sd">    Args:</span>
<span class="sd">        l_intensity_with_lipids (list(float)): A list of peak intensities (where one lipid can</span>
<span class="sd">        correspond to several</span>
<span class="sd">            peaks, but one peak always correspond to one lipid).</span>
<span class="sd">        l_idx_labels (list(int)): A list of lipid annotation, each lipid being annotated with a</span>
<span class="sd">        unique integer.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list(int), list(float): The first list provides the lipid indices, while the second provide</span>
<span class="sd">        the lipid average intensities. Peaks corresponding to identical lipid have been averaged.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define empty lists for the lipid indices and intensities</span>
    <span class="n">l_unique_idx_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">l_avg_intensity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">idx_label_temp</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="c1"># Loop over the lipid indices (i.e. m/z values)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">idx_label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">):</span>

        <span class="c1"># Actual lipid and not just a placeholder</span>
        <span class="k">if</span> <span class="n">idx_label</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># New lipid is discovered</span>
            <span class="k">if</span> <span class="n">idx_label</span> <span class="o">!=</span> <span class="n">idx_label_temp</span><span class="p">:</span>
                <span class="n">idx_label_temp</span> <span class="o">=</span> <span class="n">l_idx_labels</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">l_avg_intensity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_intensity_with_lipids</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">l_unique_idx_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx_label</span><span class="p">)</span>

            <span class="c1"># Continuity of the previous lipid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l_avg_intensity</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">l_intensity_with_lipids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">l_unique_idx_labels</span><span class="p">,</span> <span class="n">l_avg_intensity</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_image_using_index_and_image_lookup" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_image_using_index_and_image_lookup</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">,</span> <span class="n">lookup_table_spectra</span><span class="p">,</span> <span class="n">lookup_table_image</span><span class="p">,</span> <span class="n">divider_lookup</span><span class="p">,</span> <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">,</span> <span class="n">apply_transform</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function is very much similar to compute_image_using_index_lookup, except that it uses a
different lookup table: lookup_table_image. This lookup table contains the cumulated intensities
above the current lookup (instead of the sheer intensities). Therefore, any image corresponding
to the integral of all pixel spectra between two bounds can be approximated by the difference of
the lookups closest to these bounds. The integral can then be corrected a posteriori to obtain
the exact value. If the m/z distance between the two bounds is low, it calls
compute_image_using_index_lookup() as the optimization is not worth it. It wraps the internal
functions _compute_image_using_index_and_image_lookup_full() and
_compute_image_using_index_and_image_lookup_partial() to ensure that the proper array type is
used with numba.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>low_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Lower m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>high_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Higher m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>img_shape</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>A tuple with the two integer values corresponding to height and</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (k,m) representing a
lookup table with the following mapping: lookup_table_spectra[i,j] contains the first
m/z index of pixel j such that m/z &gt;= i * divider_lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table_image</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (k,m) representing a
lookup table with the following mapping: lookup_table_image[i,j] contains, for the pixel
of index j, the cumulated intensities from the lowest possible m/z until the first m/z
such that m/z &gt;= i * divider_lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>divider_lookup</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Integer used to set the resolution when building the lookup table.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_peaks_transformed_lipids</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A two-dimensional numpy array, which contains
the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,
for the lipids that have been transformed.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_corrective_factors</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A three-dimensional numpy array, which contains the
MAIA corrective factor used for lipid (first dimension) and each pixel (second and third
dimension).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>apply_transform</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If True, the MAIA correction for pixel intensity is applied.
Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated
intensity of the spectra between low_bound and high_bound, for each pixel.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span>
<span class="normal">380</span>
<span class="normal">381</span>
<span class="normal">382</span>
<span class="normal">383</span>
<span class="normal">384</span>
<span class="normal">385</span>
<span class="normal">386</span>
<span class="normal">387</span>
<span class="normal">388</span>
<span class="normal">389</span>
<span class="normal">390</span>
<span class="normal">391</span>
<span class="normal">392</span>
<span class="normal">393</span>
<span class="normal">394</span>
<span class="normal">395</span>
<span class="normal">396</span>
<span class="normal">397</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_image_using_index_and_image_lookup</span><span class="p">(</span>
    <span class="n">low_bound</span><span class="p">,</span>
    <span class="n">high_bound</span><span class="p">,</span>
    <span class="n">array_spectra</span><span class="p">,</span>
    <span class="n">array_pixel_indexes</span><span class="p">,</span>
    <span class="n">img_shape</span><span class="p">,</span>
    <span class="n">lookup_table_spectra</span><span class="p">,</span>
    <span class="n">lookup_table_image</span><span class="p">,</span>
    <span class="n">divider_lookup</span><span class="p">,</span>
    <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
    <span class="n">array_corrective_factors</span><span class="p">,</span>
    <span class="n">apply_transform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is very much similar to compute_image_using_index_lookup, except that it uses a</span>
<span class="sd">    different lookup table: lookup_table_image. This lookup table contains the cumulated intensities</span>
<span class="sd">    above the current lookup (instead of the sheer intensities). Therefore, any image corresponding</span>
<span class="sd">    to the integral of all pixel spectra between two bounds can be approximated by the difference of</span>
<span class="sd">    the lookups closest to these bounds. The integral can then be corrected a posteriori to obtain</span>
<span class="sd">    the exact value. If the m/z distance between the two bounds is low, it calls</span>
<span class="sd">    compute_image_using_index_lookup() as the optimization is not worth it. It wraps the internal</span>
<span class="sd">    functions _compute_image_using_index_and_image_lookup_full() and</span>
<span class="sd">    _compute_image_using_index_and_image_lookup_partial() to ensure that the proper array type is</span>
<span class="sd">    used with numba.</span>

<span class="sd">    Args:</span>
<span class="sd">        low_bound (float): Lower m/z value for the annotation.</span>
<span class="sd">        high_bound (float): Higher m/z value for the annotation.</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>
<span class="sd">        img_shape (tuple(int)): A tuple with the two integer values corresponding to height and</span>
<span class="sd">        width of the current slice acquisition.</span>
<span class="sd">        lookup_table_spectra (np.ndarray): An array of shape (k,m) representing a</span>
<span class="sd">            lookup table with the following mapping: lookup_table_spectra[i,j] contains the first</span>
<span class="sd">            m/z index of pixel j such that m/z &gt;= i * divider_lookup.</span>
<span class="sd">        lookup_table_image (np.ndarray): An array of shape (k,m) representing a</span>
<span class="sd">            lookup table with the following mapping: lookup_table_image[i,j] contains, for the pixel</span>
<span class="sd">            of index j, the cumulated intensities from the lowest possible m/z until the first m/z</span>
<span class="sd">            such that m/z &gt;= i * divider_lookup.</span>
<span class="sd">        divider_lookup (int): Integer used to set the resolution when building the lookup table.</span>
<span class="sd">        array_peaks_transformed_lipids (np.ndarray): A two-dimensional numpy array, which contains</span>
<span class="sd">            the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,</span>
<span class="sd">            for the lipids that have been transformed.</span>
<span class="sd">        array_corrective_factors (np.ndarray): A three-dimensional numpy array, which contains the</span>
<span class="sd">            MAIA corrective factor used for lipid (first dimension) and each pixel (second and third</span>
<span class="sd">            dimension).</span>
<span class="sd">        apply_transform (bool): If True, the MAIA correction for pixel intensity is applied.</span>
<span class="sd">            Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated</span>
<span class="sd">            intensity of the spectra between low_bound and high_bound, for each pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Image lookup table is not worth it for small differences between the bounds</span>
    <span class="c1"># And image lookup can&#39;t be used if the transformation should not be applied</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">high_bound</span> <span class="o">-</span> <span class="n">low_bound</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">5</span> <span class="ow">or</span> <span class="n">apply_transform</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">compute_image_using_index_lookup</span><span class="p">(</span>
            <span class="n">low_bound</span><span class="p">,</span>
            <span class="n">high_bound</span><span class="p">,</span>
            <span class="n">array_spectra</span><span class="p">,</span>
            <span class="n">array_pixel_indexes</span><span class="p">,</span>
            <span class="n">img_shape</span><span class="p">,</span>
            <span class="n">lookup_table_spectra</span><span class="p">,</span>
            <span class="n">divider_lookup</span><span class="p">,</span>
            <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
            <span class="n">array_corrective_factors</span><span class="p">,</span>
            <span class="n">apply_transform</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_compute_image_using_index_and_image_lookup_partial</span><span class="p">(</span>
            <span class="n">low_bound</span><span class="p">,</span>
            <span class="n">high_bound</span><span class="p">,</span>
            <span class="n">array_spectra</span><span class="p">,</span>
            <span class="n">array_pixel_indexes</span><span class="p">,</span>
            <span class="n">img_shape</span><span class="p">,</span>
            <span class="n">lookup_table_spectra</span><span class="p">,</span>
            <span class="n">lookup_table_image</span><span class="p">,</span>
            <span class="n">divider_lookup</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_image_using_index_lookup" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_image_using_index_lookup</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">img_shape</span><span class="p">,</span> <span class="n">lookup_table_spectra</span><span class="p">,</span> <span class="n">divider_lookup</span><span class="p">,</span> <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">,</span> <span class="n">apply_transform</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>For each pixel, this function extracts from array_spectra the intensity of a given m/z
selection (normally corresponding to a lipid annotation) defined by a lower and a higher bound.
For faster computation, it uses lookup_table_spectra to map m/z values to given indices. It then
assigns the pixel intensity to an array of shape img_shape, therefore producing an image
representing the requested lipid distribution.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>low_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Lower m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>high_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Higher m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum data (m/z and
intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>img_shape</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>A tuple with the two integer values corresponding to height and
width of the current slice acquisition.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (k,m) representing a lookup table with
the following mapping: lookup_table_spectra[i,j] contains the first m/z index of pixel
j such that m/z &gt;= i * divider_lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>divider_lookup</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Integer used to set the resolution when building the lookup table.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_peaks_transformed_lipids</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A two-dimensional numpy array, which contains
the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,
for the lipids that have been transformed.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_corrective_factors</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A three-dimensional numpy array, which contains the
MAIA corrective factor used for lipid (first dimension) and each pixel (second and third
dimension).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>apply_transform</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If True, the MAIA correction for pixel intensity is reverted.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated
intensity of the spectra between low_bound and high_bound, for each pixel.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_image_using_index_lookup</span><span class="p">(</span>
    <span class="n">low_bound</span><span class="p">,</span>
    <span class="n">high_bound</span><span class="p">,</span>
    <span class="n">array_spectra</span><span class="p">,</span>
    <span class="n">array_pixel_indexes</span><span class="p">,</span>
    <span class="n">img_shape</span><span class="p">,</span>
    <span class="n">lookup_table_spectra</span><span class="p">,</span>
    <span class="n">divider_lookup</span><span class="p">,</span>
    <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
    <span class="n">array_corrective_factors</span><span class="p">,</span>
    <span class="n">apply_transform</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;For each pixel, this function extracts from array_spectra the intensity of a given m/z</span>
<span class="sd">    selection (normally corresponding to a lipid annotation) defined by a lower and a higher bound.</span>
<span class="sd">    For faster computation, it uses lookup_table_spectra to map m/z values to given indices. It then</span>
<span class="sd">    assigns the pixel intensity to an array of shape img_shape, therefore producing an image</span>
<span class="sd">    representing the requested lipid distribution.</span>

<span class="sd">    Args:</span>
<span class="sd">        low_bound (float): Lower m/z value for the annotation.</span>
<span class="sd">        high_bound (float): Higher m/z value for the annotation.</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum data (m/z and</span>
<span class="sd">            intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>
<span class="sd">        img_shape (tuple(int)): A tuple with the two integer values corresponding to height and</span>
<span class="sd">            width of the current slice acquisition.</span>
<span class="sd">        lookup_table_spectra (np.ndarray): An array of shape (k,m) representing a lookup table with</span>
<span class="sd">            the following mapping: lookup_table_spectra[i,j] contains the first m/z index of pixel</span>
<span class="sd">            j such that m/z &gt;= i * divider_lookup.</span>
<span class="sd">        divider_lookup (int): Integer used to set the resolution when building the lookup table.</span>
<span class="sd">        array_peaks_transformed_lipids (np.ndarray): A two-dimensional numpy array, which contains</span>
<span class="sd">            the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,</span>
<span class="sd">            for the lipids that have been transformed.</span>
<span class="sd">        array_corrective_factors (np.ndarray): A three-dimensional numpy array, which contains the</span>
<span class="sd">            MAIA corrective factor used for lipid (first dimension) and each pixel (second and third</span>
<span class="sd">            dimension).</span>
<span class="sd">        apply_transform (bool): If True, the MAIA correction for pixel intensity is reverted.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated</span>
<span class="sd">            intensity of the spectra between low_bound and high_bound, for each pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build empty image</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Build an array of ones for the correction (i.e. default is no correction)</span>
    <span class="n">array_corrective_factors_lipid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">img_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">img_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">apply_transform</span><span class="p">:</span>
        <span class="c1"># Check if the m/z region must transformed, i.e. low and high bound are inside annotation</span>
        <span class="n">idx_lipid_right</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">idx_lipid</span><span class="p">,</span> <span class="p">(</span><span class="n">min_mz</span><span class="p">,</span> <span class="n">max_mz</span><span class="p">,</span> <span class="n">avg_mz</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_peaks_transformed_lipids</span><span class="p">):</span>
            <span class="c1"># Take 10**-4 for precision</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">low_bound</span> <span class="o">+</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">min_mz</span> <span class="ow">and</span> <span class="p">(</span><span class="n">high_bound</span> <span class="o">-</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">4</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_mz</span><span class="p">:</span>
                <span class="n">idx_lipid_right</span> <span class="o">=</span> <span class="n">idx_lipid</span>
                <span class="k">break</span>

        <span class="c1"># If the current region corresponds to a transformed lipid:</span>
        <span class="k">if</span> <span class="n">idx_lipid_right</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">array_corrective_factors_lipid</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">array_corrective_factors</span><span class="p">[</span><span class="n">idx_lipid_right</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="c1"># Find lower bound and add from there</span>
    <span class="k">for</span> <span class="n">idx_pix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_pixel_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>

        <span class="c1"># If pixel contains no peak, skip it</span>
        <span class="k">if</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Compute range in which values must be summed and extract corresponding part of spectrum</span>
        <span class="n">lower_bound</span> <span class="o">=</span> <span class="n">lookup_table_spectra</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">low_bound</span> <span class="o">/</span> <span class="n">divider_lookup</span><span class="p">)][</span><span class="n">idx_pix</span><span class="p">]</span>
        <span class="n">higher_bound</span> <span class="o">=</span> <span class="n">lookup_table_spectra</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">high_bound</span> <span class="o">/</span> <span class="n">divider_lookup</span><span class="p">))][</span><span class="n">idx_pix</span><span class="p">]</span>
        <span class="n">array_to_sum</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[:,</span> <span class="n">lower_bound</span> <span class="p">:</span> <span class="n">higher_bound</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Apply MAIA correction</span>
        <span class="k">if</span> <span class="n">array_corrective_factors_lipid</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">correction</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">correction</span> <span class="o">=</span> <span class="n">array_corrective_factors_lipid</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">]</span>

        <span class="c1"># Sum the m/z values over the requested range</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">_fill_image</span><span class="p">(</span>
            <span class="n">image</span><span class="p">,</span>
            <span class="n">idx_pix</span><span class="p">,</span>
            <span class="n">img_shape</span><span class="p">,</span>
            <span class="n">array_to_sum</span><span class="p">,</span>
            <span class="n">lower_bound</span><span class="p">,</span>
            <span class="n">higher_bound</span><span class="p">,</span>
            <span class="n">low_bound</span><span class="p">,</span>
            <span class="n">high_bound</span><span class="p">,</span>
            <span class="n">correction</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">image</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_index_boundaries" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_index_boundaries</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra_avg</span><span class="p">,</span> <span class="n">lookup_table</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function is very much similar to compute_index_boundaries_nolookup(), except that it
uses lookup_table to find the low and high bounds indices faster. As in
compute_index_boundaries_nolookup(), it computes, from array_spectra_avg, the first existing
indices corresponding to m/z values above the provided lower and higher bounds. If high_bound
and/or low_bound are above the highest possible value for the required lookup, it returns the
index of the highest existing value. Note that array_spectra_avg normally corresponds to the
high-resolution spectrum averaged across all pixels, but in can be any spectrum so long as it is
not subdivided in pixels. Also note that there are no partial full versions of this function
depending if the dataset is stored in RAM or HDF5, since the two versions would have been almost
identical (there's no loop over pixels, contrarily to e.g. compute_image_using_index_lookup(),
and a view/copy of the partial spectra in the selection is made as a first step, turning an in
a np.ndarray). It wraps the internal numba-ized function _compute_index_boundaries_nolookup().</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>low_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Lower m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>high_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Higher m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra_avg</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing
spectrum data (m/z and intensity).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1-dimensional array of length m providing, for each index (i.e.
lookup), the index of the first m/z value in the averaged array_spectra superior or
equal to the lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>tuple</code></td>          <td>
                <code>int</code>
          </td>
          <td><p>A tuple of integer representing the best guess for the indices of low_bound and</p></td>
        </tr>
        <tr>
<td></td>          <td>
          </td>
          <td><p>high_bound in array_spectra_avg.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">632</span>
<span class="normal">633</span>
<span class="normal">634</span>
<span class="normal">635</span>
<span class="normal">636</span>
<span class="normal">637</span>
<span class="normal">638</span>
<span class="normal">639</span>
<span class="normal">640</span>
<span class="normal">641</span>
<span class="normal">642</span>
<span class="normal">643</span>
<span class="normal">644</span>
<span class="normal">645</span>
<span class="normal">646</span>
<span class="normal">647</span>
<span class="normal">648</span>
<span class="normal">649</span>
<span class="normal">650</span>
<span class="normal">651</span>
<span class="normal">652</span>
<span class="normal">653</span>
<span class="normal">654</span>
<span class="normal">655</span>
<span class="normal">656</span>
<span class="normal">657</span>
<span class="normal">658</span>
<span class="normal">659</span>
<span class="normal">660</span>
<span class="normal">661</span>
<span class="normal">662</span>
<span class="normal">663</span>
<span class="normal">664</span>
<span class="normal">665</span>
<span class="normal">666</span>
<span class="normal">667</span>
<span class="normal">668</span>
<span class="normal">669</span>
<span class="normal">670</span>
<span class="normal">671</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_index_boundaries</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra_avg</span><span class="p">,</span> <span class="n">lookup_table</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is very much similar to compute_index_boundaries_nolookup(), except that it</span>
<span class="sd">    uses lookup_table to find the low and high bounds indices faster. As in</span>
<span class="sd">    compute_index_boundaries_nolookup(), it computes, from array_spectra_avg, the first existing</span>
<span class="sd">    indices corresponding to m/z values above the provided lower and higher bounds. If high_bound</span>
<span class="sd">    and/or low_bound are above the highest possible value for the required lookup, it returns the</span>
<span class="sd">    index of the highest existing value. Note that array_spectra_avg normally corresponds to the</span>
<span class="sd">    high-resolution spectrum averaged across all pixels, but in can be any spectrum so long as it is</span>
<span class="sd">    not subdivided in pixels. Also note that there are no partial full versions of this function</span>
<span class="sd">    depending if the dataset is stored in RAM or HDF5, since the two versions would have been almost</span>
<span class="sd">    identical (there&#39;s no loop over pixels, contrarily to e.g. compute_image_using_index_lookup(),</span>
<span class="sd">    and a view/copy of the partial spectra in the selection is made as a first step, turning an in</span>
<span class="sd">    a np.ndarray). It wraps the internal numba-ized function _compute_index_boundaries_nolookup().</span>

<span class="sd">    Args:</span>
<span class="sd">        low_bound (float): Lower m/z value for the annotation.</span>
<span class="sd">        high_bound (float): Higher m/z value for the annotation.</span>
<span class="sd">        array_spectra_avg (np.ndarray): An array of shape (2,n) containing</span>
<span class="sd">            spectrum data (m/z and intensity).</span>
<span class="sd">        lookup_table (np.ndarray): A 1-dimensional array of length m providing, for each index (i.e.</span>
<span class="sd">            lookup), the index of the first m/z value in the averaged array_spectra superior or</span>
<span class="sd">            equal to the lookup.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(int): A tuple of integer representing the best guess for the indices of low_bound and</span>
<span class="sd">        high_bound in array_spectra_avg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the arrays provided by the lookup table as first guess for the low and high bounds</span>
    <span class="n">array_to_sum_lb</span> <span class="o">=</span> <span class="n">array_spectra_avg</span><span class="p">[</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">lookup_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">low_bound</span><span class="p">)]</span> <span class="p">:</span> <span class="n">lookup_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">low_bound</span><span class="p">))]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">]</span>
    <span class="n">array_to_sum_hb</span> <span class="o">=</span> <span class="n">array_spectra_avg</span><span class="p">[</span>
        <span class="mi">0</span><span class="p">,</span> <span class="n">lookup_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">high_bound</span><span class="p">)]</span> <span class="p">:</span> <span class="n">lookup_table</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">high_bound</span><span class="p">))]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="p">]</span>

    <span class="c1"># Correct the lookup indices with these arrays</span>
    <span class="k">return</span> <span class="n">_loop_compute_index_boundaries</span><span class="p">(</span>
        <span class="n">array_to_sum_lb</span><span class="p">,</span> <span class="n">array_to_sum_hb</span><span class="p">,</span> <span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">lookup_table</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_index_boundaries_nolookup" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_index_boundaries_nolookup</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra_avg</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function computes, from array_spectra_avg, the first existing indices corresponding to
m/z values above the provided lower and higher bounds, without using any lookup. If high_bound
and/or low_bound are above the highest possible value for the required lookup, it returns the
index of the highest existing value. Note that array_spectra_avg normally corresponds to the
high-resolution spectrum averaged across all pixels, but in can be any spectrum so long as it is
not subdivided in pixels.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>low_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Lower m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>high_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Higher m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra_avg</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing
spectrum data (m/z and intensity).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>tuple</code></td>          <td>
                <code>int</code>
          </td>
          <td><p>A tuple of integer representing the best guess for the indices of low_bound and
high_bound in array_spectra_avg.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">591</span>
<span class="normal">592</span>
<span class="normal">593</span>
<span class="normal">594</span>
<span class="normal">595</span>
<span class="normal">596</span>
<span class="normal">597</span>
<span class="normal">598</span>
<span class="normal">599</span>
<span class="normal">600</span>
<span class="normal">601</span>
<span class="normal">602</span>
<span class="normal">603</span>
<span class="normal">604</span>
<span class="normal">605</span>
<span class="normal">606</span>
<span class="normal">607</span>
<span class="normal">608</span>
<span class="normal">609</span>
<span class="normal">610</span>
<span class="normal">611</span>
<span class="normal">612</span>
<span class="normal">613</span>
<span class="normal">614</span>
<span class="normal">615</span>
<span class="normal">616</span>
<span class="normal">617</span>
<span class="normal">618</span>
<span class="normal">619</span>
<span class="normal">620</span>
<span class="normal">621</span>
<span class="normal">622</span>
<span class="normal">623</span>
<span class="normal">624</span>
<span class="normal">625</span>
<span class="normal">626</span>
<span class="normal">627</span>
<span class="normal">628</span>
<span class="normal">629</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_index_boundaries_nolookup</span><span class="p">(</span><span class="n">low_bound</span><span class="p">,</span> <span class="n">high_bound</span><span class="p">,</span> <span class="n">array_spectra_avg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function computes, from array_spectra_avg, the first existing indices corresponding to</span>
<span class="sd">    m/z values above the provided lower and higher bounds, without using any lookup. If high_bound</span>
<span class="sd">    and/or low_bound are above the highest possible value for the required lookup, it returns the</span>
<span class="sd">    index of the highest existing value. Note that array_spectra_avg normally corresponds to the</span>
<span class="sd">    high-resolution spectrum averaged across all pixels, but in can be any spectrum so long as it is</span>
<span class="sd">    not subdivided in pixels.</span>

<span class="sd">    Args:</span>
<span class="sd">        low_bound (float): Lower m/z value for the annotation.</span>
<span class="sd">        high_bound (float): Higher m/z value for the annotation.</span>
<span class="sd">        array_spectra_avg (np.ndarray): An array of shape (2,n) containing</span>
<span class="sd">            spectrum data (m/z and intensity).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(int): A tuple of integer representing the best guess for the indices of low_bound and</span>
<span class="sd">            high_bound in array_spectra_avg.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Extract the mz values for array_spectra_avg</span>
    <span class="n">array_mz</span> <span class="o">=</span> <span class="n">array_spectra_avg</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>

    <span class="c1"># Define intial guess for the low and high bounds indices</span>
    <span class="n">index_low_bound</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">index_high_bound</span> <span class="o">=</span> <span class="n">array_mz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="c1"># Browse array_mz until low bound is crossed</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_mz</span><span class="p">):</span>
        <span class="n">index_low_bound</span> <span class="o">=</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">mz</span> <span class="o">&gt;=</span> <span class="n">low_bound</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Start from the low bound index, and browse array_mz until high bound is crossed</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">mz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array_mz</span><span class="p">[</span><span class="n">index_low_bound</span><span class="p">:]):</span>
        <span class="n">index_high_bound</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">index_low_bound</span>
        <span class="k">if</span> <span class="n">mz</span> <span class="o">&gt;=</span> <span class="n">high_bound</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">return</span> <span class="n">index_low_bound</span><span class="p">,</span> <span class="n">index_high_bound</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_normalized_image_per_lipid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_normalized_image_per_lipid</span><span class="p">(</span><span class="n">lb_mz</span><span class="p">,</span> <span class="n">hb_mz</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">lookup_table_spectra</span><span class="p">,</span> <span class="n">cumulated_image_lookup_table</span><span class="p">,</span> <span class="n">divider_lookup</span><span class="p">,</span> <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">,</span> <span class="n">apply_transform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">percentile_normalization</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">RGB_channel_format</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function is mostly a wrapper for compute_image_using_index_and_image_lookup, that is, it
computes an image containing the cumulated intensity of the spectra between low_bound and
high_bound, for each pixel. In addition, it adds a step of normalization, such that the output
is more visually pleasing and comparable across selections. The output can also be provided in
8 bits, that is, the format of a single channel in an RGB image.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>low_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Lower m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>high_bound</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Higher m/z value for the annotation.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>img_shape</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>A tuple with the two integer values corresponding to height and
width of the current slice acquisition.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (k,m) representing a
lookup table with the following mapping: lookup_table_spectra[i,j] contains the first
m/z index of pixel j such that m/z &gt;= i * divider_lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lookup_table_image</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (k,m) representing a
lookup table with the following mapping: lookup_table_image[i,j] contains, for the pixel
of index j, the cumulated intensities from the lowest possible m/z until the first m/z
such that m/z &gt;= i * divider_lookup.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>divider_lookup</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Integer used to set the resolution when building the lookup table.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_peaks_transformed_lipids</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A two-dimensional numpy array, which contains
the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,
for the lipids that have been transformed.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_corrective_factors</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A three-dimensional numpy array, which contains the
MAIA corrective factor used for lipid (first dimension) and each pixel (second and third
dimension).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>apply_transform</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If True, the MAIA correction for pixel intensity is applied.
Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>percentile_normalization</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Integer used to re-normalize the data, such that the maximum
value correspond to the given percentile.</p></td>
          <td>
                <code>99</code>
          </td>
        </tr>
        <tr>
          <td><code>RGB_channel_format</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If False, the output image is provided as an array with values
between 0 and 1. Else, the values are between 0 and 255.</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated
intensity of the spectra between low_bound and high_bound, for each pixel. This image is
normalized according to percentile_normalized. Output values are between 0 and 1 (255)
depending if RGB_channel_format is False (True).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">504</span>
<span class="normal">505</span>
<span class="normal">506</span>
<span class="normal">507</span>
<span class="normal">508</span>
<span class="normal">509</span>
<span class="normal">510</span>
<span class="normal">511</span>
<span class="normal">512</span>
<span class="normal">513</span>
<span class="normal">514</span>
<span class="normal">515</span>
<span class="normal">516</span>
<span class="normal">517</span>
<span class="normal">518</span>
<span class="normal">519</span>
<span class="normal">520</span>
<span class="normal">521</span>
<span class="normal">522</span>
<span class="normal">523</span>
<span class="normal">524</span>
<span class="normal">525</span>
<span class="normal">526</span>
<span class="normal">527</span>
<span class="normal">528</span>
<span class="normal">529</span>
<span class="normal">530</span>
<span class="normal">531</span>
<span class="normal">532</span>
<span class="normal">533</span>
<span class="normal">534</span>
<span class="normal">535</span>
<span class="normal">536</span>
<span class="normal">537</span>
<span class="normal">538</span>
<span class="normal">539</span>
<span class="normal">540</span>
<span class="normal">541</span>
<span class="normal">542</span>
<span class="normal">543</span>
<span class="normal">544</span>
<span class="normal">545</span>
<span class="normal">546</span>
<span class="normal">547</span>
<span class="normal">548</span>
<span class="normal">549</span>
<span class="normal">550</span>
<span class="normal">551</span>
<span class="normal">552</span>
<span class="normal">553</span>
<span class="normal">554</span>
<span class="normal">555</span>
<span class="normal">556</span>
<span class="normal">557</span>
<span class="normal">558</span>
<span class="normal">559</span>
<span class="normal">560</span>
<span class="normal">561</span>
<span class="normal">562</span>
<span class="normal">563</span>
<span class="normal">564</span>
<span class="normal">565</span>
<span class="normal">566</span>
<span class="normal">567</span>
<span class="normal">568</span>
<span class="normal">569</span>
<span class="normal">570</span>
<span class="normal">571</span>
<span class="normal">572</span>
<span class="normal">573</span>
<span class="normal">574</span>
<span class="normal">575</span>
<span class="normal">576</span>
<span class="normal">577</span>
<span class="normal">578</span>
<span class="normal">579</span>
<span class="normal">580</span>
<span class="normal">581</span>
<span class="normal">582</span>
<span class="normal">583</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_normalized_image_per_lipid</span><span class="p">(</span>
    <span class="n">lb_mz</span><span class="p">,</span>
    <span class="n">hb_mz</span><span class="p">,</span>
    <span class="n">array_spectra</span><span class="p">,</span>
    <span class="n">array_pixel_indexes</span><span class="p">,</span>
    <span class="n">image_shape</span><span class="p">,</span>
    <span class="n">lookup_table_spectra</span><span class="p">,</span>
    <span class="n">cumulated_image_lookup_table</span><span class="p">,</span>
    <span class="n">divider_lookup</span><span class="p">,</span>
    <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
    <span class="n">array_corrective_factors</span><span class="p">,</span>
    <span class="n">apply_transform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="n">percentile_normalization</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
    <span class="n">RGB_channel_format</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is mostly a wrapper for compute_image_using_index_and_image_lookup, that is, it</span>
<span class="sd">    computes an image containing the cumulated intensity of the spectra between low_bound and</span>
<span class="sd">    high_bound, for each pixel. In addition, it adds a step of normalization, such that the output</span>
<span class="sd">    is more visually pleasing and comparable across selections. The output can also be provided in</span>
<span class="sd">    8 bits, that is, the format of a single channel in an RGB image.</span>

<span class="sd">    Args:</span>
<span class="sd">        low_bound (float): Lower m/z value for the annotation.</span>
<span class="sd">        high_bound (float): Higher m/z value for the annotation.</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>
<span class="sd">        img_shape (tuple(int)): A tuple with the two integer values corresponding to height and</span>
<span class="sd">            width of the current slice acquisition.</span>
<span class="sd">        lookup_table_spectra (np.ndarray): An array of shape (k,m) representing a</span>
<span class="sd">            lookup table with the following mapping: lookup_table_spectra[i,j] contains the first</span>
<span class="sd">            m/z index of pixel j such that m/z &gt;= i * divider_lookup.</span>
<span class="sd">        lookup_table_image (np.ndarray): An array of shape (k,m) representing a</span>
<span class="sd">            lookup table with the following mapping: lookup_table_image[i,j] contains, for the pixel</span>
<span class="sd">            of index j, the cumulated intensities from the lowest possible m/z until the first m/z</span>
<span class="sd">            such that m/z &gt;= i * divider_lookup.</span>
<span class="sd">        divider_lookup (int): Integer used to set the resolution when building the lookup table.</span>
<span class="sd">        array_peaks_transformed_lipids (np.ndarray): A two-dimensional numpy array, which contains</span>
<span class="sd">            the peak annotations (min peak, max peak, average value of the peak), sorted by min_mz,</span>
<span class="sd">            for the lipids that have been transformed.</span>
<span class="sd">        array_corrective_factors (np.ndarray): A three-dimensional numpy array, which contains the</span>
<span class="sd">            MAIA corrective factor used for lipid (first dimension) and each pixel (second and third</span>
<span class="sd">            dimension).</span>
<span class="sd">        apply_transform (bool): If True, the MAIA correction for pixel intensity is applied.</span>
<span class="sd">            Defaults to False.</span>
<span class="sd">        percentile_normalization (int): Integer used to re-normalize the data, such that the maximum</span>
<span class="sd">            value correspond to the given percentile.</span>
<span class="sd">        RGB_channel_format (bool): If False, the output image is provided as an array with values</span>
<span class="sd">            between 0 and 1. Else, the values are between 0 and 255.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of shape img_shape (reprensenting an image) containing the cumulated</span>
<span class="sd">            intensity of the spectra between low_bound and high_bound, for each pixel. This image is</span>
<span class="sd">            normalized according to percentile_normalized. Output values are between 0 and 1 (255)</span>
<span class="sd">            depending if RGB_channel_format is False (True).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get image from raw mass spec data</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">compute_image_using_index_and_image_lookup</span><span class="p">(</span>
        <span class="n">lb_mz</span><span class="p">,</span>
        <span class="n">hb_mz</span><span class="p">,</span>
        <span class="n">array_spectra</span><span class="p">,</span>
        <span class="n">array_pixel_indexes</span><span class="p">,</span>
        <span class="n">image_shape</span><span class="p">,</span>
        <span class="n">lookup_table_spectra</span><span class="p">,</span>
        <span class="n">cumulated_image_lookup_table</span><span class="p">,</span>
        <span class="n">divider_lookup</span><span class="p">,</span>
        <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
        <span class="n">array_corrective_factors</span><span class="p">,</span>
        <span class="n">apply_transform</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Normalize by percentile</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">image</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">percentile_normalization</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span>
    <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span>

    <span class="c1"># Convert image to have values between 0 and 255</span>
    <span class="k">if</span> <span class="n">RGB_channel_format</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">*=</span> <span class="mi">255</span>
    <span class="k">return</span> <span class="n">image</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_normalized_spectra" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_normalized_spectra</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function takes an array of spectra and returns it normalized (per pixel). In pratice,
each pixel spectrum is converted into a uncompressed version, and divided by the sum of all
spectra. This might a problematic approach as there seems to be small shifts between spectra
across pixels, leading to a noise amplification after normalization.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,m) containing the normalized spectrum data (m/z and
intensity).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_normalized_spectra</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function takes an array of spectra and returns it normalized (per pixel). In pratice,</span>
<span class="sd">    each pixel spectrum is converted into a uncompressed version, and divided by the sum of all</span>
<span class="sd">    spectra. This might a problematic approach as there seems to be small shifts between spectra</span>
<span class="sd">    across pixels, leading to a noise amplification after normalization.</span>

<span class="sd">    Args:</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (np.ndarray): An array of shape (2,m) containing the normalized spectrum data (m/z and</span>
<span class="sd">            intensity).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start by converting array_spectra into a very fine-grained version</span>
    <span class="n">spectrum_sum</span> <span class="o">=</span> <span class="n">convert_array_to_fine_grained</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">hb</span><span class="o">=</span><span class="mi">1250</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">array_spectra_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">array_spectra</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

    <span class="c1"># Loop over the spectrum of each pixel</span>
    <span class="k">for</span> <span class="n">idx_pix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">array_pixel_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;_compute_normalized_spectra:&quot;</span>
            <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">idx_pix</span> <span class="o">/</span> <span class="n">array_pixel_indexes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
            <span class="o">+</span> <span class="s2">&quot; done&quot;</span>
        <span class="p">)</span>

        <span class="c1"># If pixel contains no peak, skip it</span>
        <span class="k">if</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Get the spectrum of current pixel</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span>
            <span class="p">:,</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="p">]</span>

        <span class="c1"># Out of safety, normalize the spectrum of current pixel with respect to its own sum</span>
        <span class="c1"># Might be useless since array_spectra is normally already normalized by pixel</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Then move spectrum to uncompressed version</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">convert_array_to_fine_grained</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">hb</span><span class="o">=</span><span class="mi">1250</span><span class="p">)</span>

        <span class="c1"># Then normalize with respect to all pixels</span>
        <span class="n">spectrum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/=</span> <span class="n">spectrum_sum</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Then back to original space</span>
        <span class="n">spectrum</span> <span class="o">=</span> <span class="n">strip_zeros</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>

        <span class="c1"># Store back the spectrum</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="o">==</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">array_spectra_normalized</span><span class="p">[</span>
                <span class="p">:,</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">]</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Store shorter-sized spectrum in array_spectra_normalized, rest will be zeros</span>
            <span class="n">array_spectra_normalized</span><span class="p">[</span>
                <span class="p">:,</span>
                <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="p">:</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
                <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">]</span>

    <span class="k">return</span> <span class="n">array_spectra_normalized</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_spectrum_per_row_selection" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_spectrum_per_row_selection</span><span class="p">(</span><span class="n">list_index_bound_rows</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">,</span> <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">,</span> <span class="n">zeros_extend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">apply_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function computes the average spectrum from a manual selection of rows of pixel (each
containing a spectrum). The resulting average array can be zero-padded.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>list_index_bound_rows</code></td>
          <td>
                <code>list(tuple</code>
          </td>
          <td><p>A list of lower and upper indices delimiting the range
of rows belonging to the current selection.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>list_index_bound_column_per_row</code></td>
          <td>
                <code>list(list</code>
          </td>
          <td><p>For each row (outer list), provides the index
of the columns delimiting the current selection (inner list).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>image_shape</code></td>
          <td>
                <code>int, int</code>
          </td>
          <td><p>A tuple of integers, indicating the vertical and horizontal sizes of
the current slice.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_peaks_transformed_lipids</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A numpy array containing the peak annotations
(min peak, max peak, number of pixels containing the peak, average value of the peak),
filtered for the lipids who have preliminarily been transformed. Sorted by min_mz.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_corrective_factors</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A numpy array of shape (n_lipids, image_shape[0],
image_shape[1]) containing the corrective factors for the lipids we want to visualize,
for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>zeros_extend</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If True, the resulting spectrum will be zero-padded. Defaults
to True.</p></td>
          <td>
                <code>True</code>
          </td>
        </tr>
        <tr>
          <td><code>apply_correction</code></td>
          <td>
                <code>bool</code>
          </td>
          <td><p>If True, MAIA transformation is applied to the lipids
belonging to array_peaks_transformed_lipids, for each pixel. This option makes the
computation very slow, so it shouldn't be selected if the computations must be done on
the fly. Defaults to False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: Spectrum averaged from a manual selection of rows of pixel, containing m/z
values in the first row, and intensities in the second row.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 932</span>
<span class="normal"> 933</span>
<span class="normal"> 934</span>
<span class="normal"> 935</span>
<span class="normal"> 936</span>
<span class="normal"> 937</span>
<span class="normal"> 938</span>
<span class="normal"> 939</span>
<span class="normal"> 940</span>
<span class="normal"> 941</span>
<span class="normal"> 942</span>
<span class="normal"> 943</span>
<span class="normal"> 944</span>
<span class="normal"> 945</span>
<span class="normal"> 946</span>
<span class="normal"> 947</span>
<span class="normal"> 948</span>
<span class="normal"> 949</span>
<span class="normal"> 950</span>
<span class="normal"> 951</span>
<span class="normal"> 952</span>
<span class="normal"> 953</span>
<span class="normal"> 954</span>
<span class="normal"> 955</span>
<span class="normal"> 956</span>
<span class="normal"> 957</span>
<span class="normal"> 958</span>
<span class="normal"> 959</span>
<span class="normal"> 960</span>
<span class="normal"> 961</span>
<span class="normal"> 962</span>
<span class="normal"> 963</span>
<span class="normal"> 964</span>
<span class="normal"> 965</span>
<span class="normal"> 966</span>
<span class="normal"> 967</span>
<span class="normal"> 968</span>
<span class="normal"> 969</span>
<span class="normal"> 970</span>
<span class="normal"> 971</span>
<span class="normal"> 972</span>
<span class="normal"> 973</span>
<span class="normal"> 974</span>
<span class="normal"> 975</span>
<span class="normal"> 976</span>
<span class="normal"> 977</span>
<span class="normal"> 978</span>
<span class="normal"> 979</span>
<span class="normal"> 980</span>
<span class="normal"> 981</span>
<span class="normal"> 982</span>
<span class="normal"> 983</span>
<span class="normal"> 984</span>
<span class="normal"> 985</span>
<span class="normal"> 986</span>
<span class="normal"> 987</span>
<span class="normal"> 988</span>
<span class="normal"> 989</span>
<span class="normal"> 990</span>
<span class="normal"> 991</span>
<span class="normal"> 992</span>
<span class="normal"> 993</span>
<span class="normal"> 994</span>
<span class="normal"> 995</span>
<span class="normal"> 996</span>
<span class="normal"> 997</span>
<span class="normal"> 998</span>
<span class="normal"> 999</span>
<span class="normal">1000</span>
<span class="normal">1001</span>
<span class="normal">1002</span>
<span class="normal">1003</span>
<span class="normal">1004</span>
<span class="normal">1005</span>
<span class="normal">1006</span>
<span class="normal">1007</span>
<span class="normal">1008</span>
<span class="normal">1009</span>
<span class="normal">1010</span>
<span class="normal">1011</span>
<span class="normal">1012</span>
<span class="normal">1013</span>
<span class="normal">1014</span>
<span class="normal">1015</span>
<span class="normal">1016</span>
<span class="normal">1017</span>
<span class="normal">1018</span>
<span class="normal">1019</span>
<span class="normal">1020</span>
<span class="normal">1021</span>
<span class="normal">1022</span>
<span class="normal">1023</span>
<span class="normal">1024</span>
<span class="normal">1025</span>
<span class="normal">1026</span>
<span class="normal">1027</span>
<span class="normal">1028</span>
<span class="normal">1029</span>
<span class="normal">1030</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_spectrum_per_row_selection</span><span class="p">(</span>
    <span class="n">list_index_bound_rows</span><span class="p">,</span>
    <span class="n">list_index_bound_column_per_row</span><span class="p">,</span>
    <span class="n">array_spectra</span><span class="p">,</span>
    <span class="n">array_pixel_indexes</span><span class="p">,</span>
    <span class="n">image_shape</span><span class="p">,</span>
    <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
    <span class="n">array_corrective_factors</span><span class="p">,</span>
    <span class="n">zeros_extend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">apply_correction</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function computes the average spectrum from a manual selection of rows of pixel (each</span>
<span class="sd">    containing a spectrum). The resulting average array can be zero-padded.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_index_bound_rows (list(tuple)): A list of lower and upper indices delimiting the range</span>
<span class="sd">            of rows belonging to the current selection.</span>
<span class="sd">        list_index_bound_column_per_row (list(list)): For each row (outer list), provides the index</span>
<span class="sd">            of the columns delimiting the current selection (inner list).</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>
<span class="sd">        image_shape (int, int): A tuple of integers, indicating the vertical and horizontal sizes of</span>
<span class="sd">            the current slice.</span>
<span class="sd">        array_peaks_transformed_lipids (np.ndarray): A numpy array containing the peak annotations</span>
<span class="sd">            (min peak, max peak, number of pixels containing the peak, average value of the peak),</span>
<span class="sd">            filtered for the lipids who have preliminarily been transformed. Sorted by min_mz.</span>
<span class="sd">        array_corrective_factors (np.ndarray): A numpy array of shape (n_lipids, image_shape[0],</span>
<span class="sd">            image_shape[1]) containing the corrective factors for the lipids we want to visualize,</span>
<span class="sd">            for each pixel.</span>
<span class="sd">        zeros_extend (bool, optional): If True, the resulting spectrum will be zero-padded. Defaults</span>
<span class="sd">            to True.</span>
<span class="sd">        apply_correction (bool, optional): If True, MAIA transformation is applied to the lipids</span>
<span class="sd">            belonging to array_peaks_transformed_lipids, for each pixel. This option makes the</span>
<span class="sd">            computation very slow, so it shouldn&#39;t be selected if the computations must be done on</span>
<span class="sd">            the fly. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: Spectrum averaged from a manual selection of rows of pixel, containing m/z</span>
<span class="sd">            values in the first row, and intensities in the second row.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get list of row indexes for the current selection</span>
    <span class="n">ll_idx</span><span class="p">,</span> <span class="n">size_array</span><span class="p">,</span> <span class="n">ll_idx_pix</span> <span class="o">=</span> <span class="n">get_list_row_indexes</span><span class="p">(</span>
        <span class="n">list_index_bound_rows</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">image_shape</span>
    <span class="p">)</span>

    <span class="c1"># Init array selection of size size_array</span>
    <span class="n">array_spectra_selection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">size_array</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Fill array line by line</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">list_index_bound_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list_index_bound_rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">idx_1</span><span class="p">,</span> <span class="n">idx_2</span><span class="p">,</span> <span class="n">idx_pix_1</span><span class="p">,</span> <span class="n">idx_pix_2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
            <span class="n">ll_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">ll_idx</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">],</span> <span class="n">ll_idx_pix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">],</span> <span class="n">ll_idx_pix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">apply_correction</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">idx_pix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx_pix_1</span><span class="p">,</span> <span class="n">idx_pix_2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">idx_mz_1</span><span class="p">,</span> <span class="n">idx_mz_2</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">]</span>
                    <span class="c1"># If the pixel is not empty</span>
                    <span class="k">if</span> <span class="n">idx_mz_2</span> <span class="o">-</span> <span class="n">idx_mz_1</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">array_spectra_pix_to_correct</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span>
                            <span class="p">:,</span> <span class="n">idx_mz_1</span> <span class="p">:</span> <span class="n">idx_mz_2</span> <span class="o">+</span> <span class="mi">1</span>
                        <span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                        <span class="n">array_spectra_pix_corrected</span><span class="p">,</span> <span class="n">n_peaks_transformed</span> <span class="o">=</span> <span class="n">compute_standardization</span><span class="p">(</span>
                            <span class="n">array_spectra_pix_to_correct</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                            <span class="n">idx_pix</span><span class="p">,</span>
                            <span class="n">array_peaks_transformed_lipids</span><span class="p">,</span>
                            <span class="n">array_corrective_factors</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="n">array_spectra_selection</span><span class="p">[</span>
                            <span class="p">:,</span> <span class="n">pad</span> <span class="p">:</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">idx_mz_2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_mz_1</span>
                        <span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra_pix_corrected</span><span class="o">.</span><span class="n">T</span>
                        <span class="n">pad</span> <span class="o">+=</span> <span class="n">idx_mz_2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_mz_1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">array_spectra_selection</span><span class="p">[:,</span> <span class="n">pad</span> <span class="p">:</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">idx_2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_1</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_spectra</span><span class="p">[</span>
                    <span class="p">:,</span> <span class="n">idx_1</span> <span class="p">:</span> <span class="n">idx_2</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">]</span>
                <span class="n">pad</span> <span class="o">+=</span> <span class="n">idx_2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_1</span>

    <span class="c1"># Sort array</span>
    <span class="n">array_spectra_selection</span> <span class="o">=</span> <span class="n">array_spectra_selection</span><span class="p">[:,</span> <span class="n">array_spectra_selection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">()]</span>

    <span class="c1"># Remove the values that have been zeroed-out</span>
    <span class="k">if</span> <span class="n">apply_correction</span><span class="p">:</span>
        <span class="n">array_spectra_selection</span> <span class="o">=</span> <span class="n">strip_zeros</span><span class="p">(</span><span class="n">array_spectra_selection</span><span class="p">)</span>

    <span class="c1"># Sum the arrays (similar m/z values are added)</span>
    <span class="n">array_spectra_selection</span> <span class="o">=</span> <span class="n">reduce_resolution_sorted_array_spectra</span><span class="p">(</span>
        <span class="n">array_spectra_selection</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">4</span>
    <span class="p">)</span>

    <span class="c1"># Pad with zeros if asked</span>
    <span class="k">if</span> <span class="n">zeros_extend</span><span class="p">:</span>
        <span class="n">array_spectra_selection</span><span class="p">,</span> <span class="n">array_index_padding</span> <span class="o">=</span> <span class="n">add_zeros_to_spectrum</span><span class="p">(</span>
            <span class="n">array_spectra_selection</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">array_spectra_selection</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_standardization" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_standardization</span><span class="p">(</span><span class="n">array_spectra_pixel</span><span class="p">,</span> <span class="n">idx_pixel</span><span class="p">,</span> <span class="n">array_peaks</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function takes the spectrum data of a given pixel, along with the corresponding pixel
index, and transforms the value of the lipids intensities annotated in 'array_peaks' according
to the transformation registered in 'array_corrective_factors'.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A numpy array containing spectrum data (m/z and intensity) of
pixel 'idx_pixel', sorted by mz.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>idx_pixel</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Index of the current pixel whose spectrum is transformed.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_peaks</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A numpy array containing the peak annotations (min peak, max peak,
average value of the peak), filtered for the lipids who have preliminarily been
transformed. Sorted by min_mz.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_corrective_factors</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A numpy array of shape (n_lipids, image_shape[0],
image_shape[1]) containing the corrective factors for the lipids we want to visualize,
for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: A numpy array containing spectrum data (pixel index, m/z and intensity), of
pixel 'idx_pixel', sorted by mz, with lipids values transformed.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">864</span>
<span class="normal">865</span>
<span class="normal">866</span>
<span class="normal">867</span>
<span class="normal">868</span>
<span class="normal">869</span>
<span class="normal">870</span>
<span class="normal">871</span>
<span class="normal">872</span>
<span class="normal">873</span>
<span class="normal">874</span>
<span class="normal">875</span>
<span class="normal">876</span>
<span class="normal">877</span>
<span class="normal">878</span>
<span class="normal">879</span>
<span class="normal">880</span>
<span class="normal">881</span>
<span class="normal">882</span>
<span class="normal">883</span>
<span class="normal">884</span>
<span class="normal">885</span>
<span class="normal">886</span>
<span class="normal">887</span>
<span class="normal">888</span>
<span class="normal">889</span>
<span class="normal">890</span>
<span class="normal">891</span>
<span class="normal">892</span>
<span class="normal">893</span>
<span class="normal">894</span>
<span class="normal">895</span>
<span class="normal">896</span>
<span class="normal">897</span>
<span class="normal">898</span>
<span class="normal">899</span>
<span class="normal">900</span>
<span class="normal">901</span>
<span class="normal">902</span>
<span class="normal">903</span>
<span class="normal">904</span>
<span class="normal">905</span>
<span class="normal">906</span>
<span class="normal">907</span>
<span class="normal">908</span>
<span class="normal">909</span>
<span class="normal">910</span>
<span class="normal">911</span>
<span class="normal">912</span>
<span class="normal">913</span>
<span class="normal">914</span>
<span class="normal">915</span>
<span class="normal">916</span>
<span class="normal">917</span>
<span class="normal">918</span>
<span class="normal">919</span>
<span class="normal">920</span>
<span class="normal">921</span>
<span class="normal">922</span>
<span class="normal">923</span>
<span class="normal">924</span>
<span class="normal">925</span>
<span class="normal">926</span>
<span class="normal">927</span>
<span class="normal">928</span>
<span class="normal">929</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_standardization</span><span class="p">(</span><span class="n">array_spectra_pixel</span><span class="p">,</span> <span class="n">idx_pixel</span><span class="p">,</span> <span class="n">array_peaks</span><span class="p">,</span> <span class="n">array_corrective_factors</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function takes the spectrum data of a given pixel, along with the corresponding pixel</span>
<span class="sd">    index, and transforms the value of the lipids intensities annotated in &#39;array_peaks&#39; according</span>
<span class="sd">    to the transformation registered in &#39;array_corrective_factors&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        array_spectra (np.ndarray): A numpy array containing spectrum data (m/z and intensity) of</span>
<span class="sd">            pixel &#39;idx_pixel&#39;, sorted by mz.</span>
<span class="sd">        idx_pixel (int): Index of the current pixel whose spectrum is transformed.</span>
<span class="sd">        array_peaks (np.ndarray): A numpy array containing the peak annotations (min peak, max peak,</span>
<span class="sd">            average value of the peak), filtered for the lipids who have preliminarily been</span>
<span class="sd">            transformed. Sorted by min_mz.</span>
<span class="sd">        array_corrective_factors (np.ndarray): A numpy array of shape (n_lipids, image_shape[0],</span>
<span class="sd">            image_shape[1]) containing the corrective factors for the lipids we want to visualize,</span>
<span class="sd">            for each pixel.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A numpy array containing spectrum data (pixel index, m/z and intensity), of</span>
<span class="sd">            pixel &#39;idx_pixel&#39;, sorted by mz, with lipids values transformed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define initial values</span>
    <span class="n">idx_peak</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx_mz</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">n_peaks_transformed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx_mz</span> <span class="o">&lt;</span> <span class="n">array_spectra_pixel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">idx_peak</span> <span class="o">&lt;</span> <span class="n">array_peaks</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">mz</span><span class="p">,</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">array_spectra_pixel</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span>
        <span class="n">min_mz</span><span class="p">,</span> <span class="n">max_mz</span><span class="p">,</span> <span class="n">mz_estimated</span> <span class="o">=</span> <span class="n">array_peaks</span><span class="p">[</span><span class="n">idx_peak</span><span class="p">]</span>

        <span class="c1"># New window has been discovered</span>
        <span class="k">if</span> <span class="n">mz</span> <span class="o">&gt;=</span> <span class="n">min_mz</span> <span class="ow">and</span> <span class="n">mz</span> <span class="o">&lt;=</span> <span class="n">max_mz</span><span class="p">:</span>
            <span class="n">idx_min_mz</span> <span class="o">=</span> <span class="n">idx_mz</span>
            <span class="n">idx_max_mz</span> <span class="o">=</span> <span class="n">idx_mz</span>
            <span class="k">for</span> <span class="n">idx_mz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">idx_min_mz</span><span class="p">,</span> <span class="n">array_spectra_pixel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">mz</span><span class="p">,</span> <span class="n">intensity</span> <span class="o">=</span> <span class="n">array_spectra_pixel</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">mz</span> <span class="o">&gt;</span> <span class="n">max_mz</span><span class="p">:</span>
                    <span class="n">idx_max_mz</span> <span class="o">=</span> <span class="n">idx_mz</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="k">break</span>

            <span class="c1"># Most likely, the annotation doesn&#39;t exist, so skip it</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">idx_max_mz</span> <span class="o">-</span> <span class="n">idx_min_mz</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mf">0.9</span><span class="p">:</span>
                <span class="c1"># Zero-out value that do not belong to the MAIA-transformed regions</span>
                <span class="n">array_spectra_pixel</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># Else compute a multiplicative factor</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="c1"># Get array of intensity before and after correction for current pixel</span>
                <span class="n">correction</span> <span class="o">=</span> <span class="n">array_corrective_factors</span><span class="p">[</span><span class="n">idx_peak</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">idx_pixel</span><span class="p">]</span>

                <span class="c1"># Multiply all intensities in the window by the corrective coefficient</span>
                <span class="n">array_spectra_pixel</span><span class="p">[</span><span class="n">idx_min_mz</span> <span class="p">:</span> <span class="n">idx_max_mz</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="n">correction</span>
                <span class="n">n_peaks_transformed</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Move on to the next peak</span>
            <span class="n">idx_peak</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mz</span> <span class="o">&gt;</span> <span class="n">max_mz</span><span class="p">:</span>
                <span class="n">idx_peak</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># zero-out value that do not belong to the MAIA-transformed regions</span>
                <span class="n">array_spectra_pixel</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">idx_mz</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">array_spectra_pixel</span><span class="p">,</span> <span class="n">n_peaks_transformed</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_thread_safe_function" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_thread_safe_function</span><span class="p">(</span><span class="n">compute_function</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">slice_index</span><span class="p">,</span> <span class="o">*</span><span class="n">args_compute_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_compute_function</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function is a wrapper for safe multithreading and multiprocessing execution of
compute_function. This is needed due to the regular cleansing of memory-mapped object.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>compute_function</code></td>
          <td>
                <code>func</code>
          </td>
          <td><p>The function/method whose result must be loaded/saved.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>cache</code></td>
          <td>
                <code>flask_caching.<span title="flask_caching.Cache">Cache</span></code>
          </td>
          <td><p>A caching object, used to check if the reading of memory-mapped
data is safe</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>*args_compute_function</code></td>
          <td>
          </td>
          <td><p>Arguments of compute_function.</p></td>
          <td>
                <code>()</code>
          </td>
        </tr>
        <tr>
          <td><code>*kwargs_compute_function</code></td>
          <td>
          </td>
          <td><p>Named arguments of compute_function.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>The result of compute_function. Type may vary depending on compute_function.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1371</span>
<span class="normal">1372</span>
<span class="normal">1373</span>
<span class="normal">1374</span>
<span class="normal">1375</span>
<span class="normal">1376</span>
<span class="normal">1377</span>
<span class="normal">1378</span>
<span class="normal">1379</span>
<span class="normal">1380</span>
<span class="normal">1381</span>
<span class="normal">1382</span>
<span class="normal">1383</span>
<span class="normal">1384</span>
<span class="normal">1385</span>
<span class="normal">1386</span>
<span class="normal">1387</span>
<span class="normal">1388</span>
<span class="normal">1389</span>
<span class="normal">1390</span>
<span class="normal">1391</span>
<span class="normal">1392</span>
<span class="normal">1393</span>
<span class="normal">1394</span>
<span class="normal">1395</span>
<span class="normal">1396</span>
<span class="normal">1397</span>
<span class="normal">1398</span>
<span class="normal">1399</span>
<span class="normal">1400</span>
<span class="normal">1401</span>
<span class="normal">1402</span>
<span class="normal">1403</span>
<span class="normal">1404</span>
<span class="normal">1405</span>
<span class="normal">1406</span>
<span class="normal">1407</span>
<span class="normal">1408</span>
<span class="normal">1409</span>
<span class="normal">1410</span>
<span class="normal">1411</span>
<span class="normal">1412</span>
<span class="normal">1413</span>
<span class="normal">1414</span>
<span class="normal">1415</span>
<span class="normal">1416</span>
<span class="normal">1417</span>
<span class="normal">1418</span>
<span class="normal">1419</span>
<span class="normal">1420</span>
<span class="normal">1421</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">compute_thread_safe_function</span><span class="p">(</span>
    <span class="n">compute_function</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">slice_index</span><span class="p">,</span> <span class="o">*</span><span class="n">args_compute_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_compute_function</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is a wrapper for safe multithreading and multiprocessing execution of</span>
<span class="sd">    compute_function. This is needed due to the regular cleansing of memory-mapped object.</span>

<span class="sd">    Args:</span>
<span class="sd">        compute_function (func): The function/method whose result must be loaded/saved.</span>
<span class="sd">        cache (flask_caching.Cache): A caching object, used to check if the reading of memory-mapped</span>
<span class="sd">            data is safe</span>
<span class="sd">        *args_compute_function: Arguments of compute_function.</span>
<span class="sd">        *kwargs_compute_function: Named arguments of compute_function.</span>

<span class="sd">    Returns:</span>
<span class="sd">        The result of compute_function. Type may vary depending on compute_function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Trying to compute the thread-safe version of &quot;</span>
        <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">compute_function</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;at&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

        <span class="c1"># Wait for the data to be safe for reading</span>
        <span class="k">while</span> <span class="n">cache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;locked-cleaning&quot;</span><span class="p">):</span>
            <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>

        <span class="c1"># Lock it while while it&#39;s being read</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;locked-reading&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No cache provided, the thread unsafe version of the function will be run&quot;</span><span class="p">)</span>

    <span class="c1"># Run the actual function</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">compute_function</span><span class="p">(</span><span class="o">*</span><span class="n">args_compute_function</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs_compute_function</span><span class="p">)</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">logging</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;The function &quot;</span><span class="si">%s</span><span class="s1">&quot; failed to run&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">compute_function</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">cache</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Unlock the data</span>
        <span class="n">cache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;locked-reading&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Clean the memory-mapped data</span>
        <span class="n">data</span><span class="o">.</span><span class="n">clean_memory</span><span class="p">(</span><span class="n">slice_index</span><span class="o">=</span><span class="n">slice_index</span><span class="p">,</span> <span class="n">cache</span><span class="o">=</span><span class="n">cache</span><span class="p">)</span>

    <span class="c1"># Return result</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.compute_zeros_extended_spectrum_per_pixel" class="doc doc-heading">
<code class="highlight language-python"><span class="n">compute_zeros_extended_spectrum_per_pixel</span><span class="p">(</span><span class="n">idx_pix</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function computes a zero-extended version of the spectrum of pixel indexed by idx_pix.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>idx_pix</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Index of the pixel to return.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: An array of shape (2,m) containing the zero-padded spectrum data (m/z and
intensity) for the requested pixel.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">813</span>
<span class="normal">814</span>
<span class="normal">815</span>
<span class="normal">816</span>
<span class="normal">817</span>
<span class="normal">818</span>
<span class="normal">819</span>
<span class="normal">820</span>
<span class="normal">821</span>
<span class="normal">822</span>
<span class="normal">823</span>
<span class="normal">824</span>
<span class="normal">825</span>
<span class="normal">826</span>
<span class="normal">827</span>
<span class="normal">828</span>
<span class="normal">829</span>
<span class="normal">830</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">compute_zeros_extended_spectrum_per_pixel</span><span class="p">(</span><span class="n">idx_pix</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function computes a zero-extended version of the spectrum of pixel indexed by idx_pix.</span>

<span class="sd">    Args:</span>
<span class="sd">        idx_pix (int): Index of the pixel to return.</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of shape (2,m) containing the zero-padded spectrum data (m/z and</span>
<span class="sd">            intensity) for the requested pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array_spectra</span> <span class="o">=</span> <span class="n">return_spectrum_per_pixel</span><span class="p">(</span><span class="n">idx_pix</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">)</span>
    <span class="n">new_array_spectra</span><span class="p">,</span> <span class="n">array_index_padding</span> <span class="o">=</span> <span class="n">add_zeros_to_spectrum</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_array_spectra</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.convert_array_to_fine_grained" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_array_to_fine_grained</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">hb</span><span class="o">=</span><span class="mi">1250</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function converts an array to a fine-grained version, which is common to all pixels,
allowing for easier computations. If several values of the compressed version map to the same
value of the uncompressed one, they are summed. Therefore, when ran on the spectrum of a whole
image, it adds the spectra of all pixels.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum data (m/z
and intensity).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>resolution</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The resolution used for finer-graining.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lb</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Lower bound for the fine-grained array. Defaults to 350.</p></td>
          <td>
                <code>350</code>
          </td>
        </tr>
        <tr>
          <td><code>hb</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Higher bound for the fine-grained array. Defaults to 1250.</p></td>
          <td>
                <code>1250</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: A sparse, fine-grained array of shape (2,m) containing spectrum data (m/z and</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>intensity).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">convert_array_to_fine_grained</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">lb</span><span class="o">=</span><span class="mi">350</span><span class="p">,</span> <span class="n">hb</span><span class="o">=</span><span class="mi">1250</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function converts an array to a fine-grained version, which is common to all pixels,</span>
<span class="sd">    allowing for easier computations. If several values of the compressed version map to the same</span>
<span class="sd">    value of the uncompressed one, they are summed. Therefore, when ran on the spectrum of a whole</span>
<span class="sd">    image, it adds the spectra of all pixels.</span>

<span class="sd">    Args:</span>
<span class="sd">        array (np.ndarray): An array of shape (2,n) containing spectrum data (m/z</span>
<span class="sd">            and intensity).</span>
<span class="sd">        resolution (float): The resolution used for finer-graining.</span>
<span class="sd">        lb (int, optional): Lower bound for the fine-grained array. Defaults to 350.</span>
<span class="sd">        hb (int, optional): Higher bound for the fine-grained array. Defaults to 1250.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A sparse, fine-grained array of shape (2,m) containing spectrum data (m/z and</span>
<span class="sd">        intensity).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build an empty (zeroed) array with the requested uncompressed size</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span> <span class="n">hb</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">hb</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)))</span>
    <span class="n">new_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">new_array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">new_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)))</span>

    <span class="c1"># Fill it with the values from the compressed array</span>
    <span class="k">for</span> <span class="n">mz</span><span class="p">,</span> <span class="n">intensity</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">T</span><span class="p">:</span>
        <span class="n">new_array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">((</span><span class="n">mz</span> <span class="o">-</span> <span class="n">lb</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)))]</span> <span class="o">+=</span> <span class="n">intensity</span>

    <span class="k">return</span> <span class="n">new_array</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.convert_coor_to_spectrum_idx" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_coor_to_spectrum_idx</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function takes a tuple of integers representing the coordinates of the pixel in the
current slice and converts it into an index in a flattened version of the image.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>coordinate</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>Coordinate in the original image.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>shape</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>Shape of the MALDI acquisition of the corresponding slice.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>int</code></td>          <td>
          </td>
          <td><p>Pixel index in a flattened version of the slice image.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">convert_coor_to_spectrum_idx</span><span class="p">(</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function takes a tuple of integers representing the coordinates of the pixel in the</span>
<span class="sd">    current slice and converts it into an index in a flattened version of the image.</span>

<span class="sd">    Args:</span>
<span class="sd">        coordinate tuple(int): Coordinate in the original image.</span>
<span class="sd">        shape (tuple(int)): Shape of the MALDI acquisition of the corresponding slice.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: Pixel index in a flattened version of the slice image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="c1"># logging.warning(&quot;Index not allowed.&quot;)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">return</span> <span class="n">ind</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.convert_spectrum_idx_to_coor" class="doc doc-heading">
<code class="highlight language-python"><span class="n">convert_spectrum_idx_to_coor</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">shape</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function takes a pixel index and converts it into a tuple of integers representing the
coordinates of the pixel in the current slice.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>index</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Pixel index in a flattened version of the slice image.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>shape</code></td>
          <td>
                <code>tuple(int</code>
          </td>
          <td><p>Shape of the MALDI acquisition of the corresponding slice.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>tuple</code></td>          <td>
                <code>int</code>
          </td>
          <td><p>Corresponding coordinate in the original image.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">convert_spectrum_idx_to_coor</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function takes a pixel index and converts it into a tuple of integers representing the</span>
<span class="sd">    coordinates of the pixel in the current slice.</span>

<span class="sd">    Args:</span>
<span class="sd">        index (int): Pixel index in a flattened version of the slice image.</span>
<span class="sd">        shape (tuple(int)): Shape of the MALDI acquisition of the corresponding slice.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple(int): Corresponding coordinate in the original image.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span> <span class="o">%</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.get_list_row_indexes" class="doc doc-heading">
<code class="highlight language-python"><span class="n">get_list_row_indexes</span><span class="p">(</span><span class="n">list_index_bound_rows</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">image_shape</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function turns a selection of rows (bounds in list_index_bound_rows) and corresponding
columns (bounds in list_index_bound_column_per_row) into an optimized list of pixel indices in
array_spectra. It takes advantage of the fact that pixels that are neighbours in a given rows
also have contiguous spectra in array_spectra, allowing for faster query.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>list_index_bound_rows</code></td>
          <td>
                <code>list(tuple</code>
          </td>
          <td><p>A list of lower and upper indices delimiting the range
of rows belonging to the current selection.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>list_index_bound_column_per_row</code></td>
          <td>
                <code>list(list</code>
          </td>
          <td><p>For each row (outer list), provides the index
of the columns delimiting the current selection (inner list).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>image_shape</code></td>
          <td>
                <code>int, int</code>
          </td>
          <td><p>A tuple of integers, indicating the vertical and horizontal sizes of
the current slice.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td></td>          <td>
                <code>list(list</code>
          </td>
          <td><p>List of 2-elements lists which contains the mz indices (inner list) in
array_spectra of the extrema pixel for each row (outer list).</p></td>
        </tr>
        <tr>
<td><code>int</code></td>          <td>
          </td>
          <td><p>Total size of the concatenated spectra indexed</p></td>
        </tr>
        <tr>
<td><code>list</code></td>          <td>
                <code>list)</code>
          </td>
          <td><p>List of 2-elements lists which contains pixels indices (inner list) in
array_spectra of the extrema pixel for each row (outer list).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1033</span>
<span class="normal">1034</span>
<span class="normal">1035</span>
<span class="normal">1036</span>
<span class="normal">1037</span>
<span class="normal">1038</span>
<span class="normal">1039</span>
<span class="normal">1040</span>
<span class="normal">1041</span>
<span class="normal">1042</span>
<span class="normal">1043</span>
<span class="normal">1044</span>
<span class="normal">1045</span>
<span class="normal">1046</span>
<span class="normal">1047</span>
<span class="normal">1048</span>
<span class="normal">1049</span>
<span class="normal">1050</span>
<span class="normal">1051</span>
<span class="normal">1052</span>
<span class="normal">1053</span>
<span class="normal">1054</span>
<span class="normal">1055</span>
<span class="normal">1056</span>
<span class="normal">1057</span>
<span class="normal">1058</span>
<span class="normal">1059</span>
<span class="normal">1060</span>
<span class="normal">1061</span>
<span class="normal">1062</span>
<span class="normal">1063</span>
<span class="normal">1064</span>
<span class="normal">1065</span>
<span class="normal">1066</span>
<span class="normal">1067</span>
<span class="normal">1068</span>
<span class="normal">1069</span>
<span class="normal">1070</span>
<span class="normal">1071</span>
<span class="normal">1072</span>
<span class="normal">1073</span>
<span class="normal">1074</span>
<span class="normal">1075</span>
<span class="normal">1076</span>
<span class="normal">1077</span>
<span class="normal">1078</span>
<span class="normal">1079</span>
<span class="normal">1080</span>
<span class="normal">1081</span>
<span class="normal">1082</span>
<span class="normal">1083</span>
<span class="normal">1084</span>
<span class="normal">1085</span>
<span class="normal">1086</span>
<span class="normal">1087</span>
<span class="normal">1088</span>
<span class="normal">1089</span>
<span class="normal">1090</span>
<span class="normal">1091</span>
<span class="normal">1092</span>
<span class="normal">1093</span>
<span class="normal">1094</span>
<span class="normal">1095</span>
<span class="normal">1096</span>
<span class="normal">1097</span>
<span class="normal">1098</span>
<span class="normal">1099</span>
<span class="normal">1100</span>
<span class="normal">1101</span>
<span class="normal">1102</span>
<span class="normal">1103</span>
<span class="normal">1104</span>
<span class="normal">1105</span>
<span class="normal">1106</span>
<span class="normal">1107</span>
<span class="normal">1108</span>
<span class="normal">1109</span>
<span class="normal">1110</span>
<span class="normal">1111</span>
<span class="normal">1112</span>
<span class="normal">1113</span>
<span class="normal">1114</span>
<span class="normal">1115</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">get_list_row_indexes</span><span class="p">(</span>
    <span class="n">list_index_bound_rows</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">,</span> <span class="n">image_shape</span>
<span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function turns a selection of rows (bounds in list_index_bound_rows) and corresponding</span>
<span class="sd">    columns (bounds in list_index_bound_column_per_row) into an optimized list of pixel indices in</span>
<span class="sd">    array_spectra. It takes advantage of the fact that pixels that are neighbours in a given rows</span>
<span class="sd">    also have contiguous spectra in array_spectra, allowing for faster query.</span>

<span class="sd">    Args:</span>
<span class="sd">        list_index_bound_rows (list(tuple)): A list of lower and upper indices delimiting the range</span>
<span class="sd">            of rows belonging to the current selection.</span>
<span class="sd">        list_index_bound_column_per_row (list(list)): For each row (outer list), provides the index</span>
<span class="sd">            of the columns delimiting the current selection (inner list).</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>
<span class="sd">        image_shape (int, int): A tuple of integers, indicating the vertical and horizontal sizes of</span>
<span class="sd">            the current slice.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (list(list): List of 2-elements lists which contains the mz indices (inner list) in</span>
<span class="sd">            array_spectra of the extrema pixel for each row (outer list).</span>
<span class="sd">        int: Total size of the concatenated spectra indexed</span>
<span class="sd">        list(list)):  List of 2-elements lists which contains pixels indices (inner list) in</span>
<span class="sd">            array_spectra of the extrema pixel for each row (outer list).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Compute size array</span>
    <span class="n">size_array</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ll_idx</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ll_idx_pix</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Loop over rows in the selection</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">list_index_bound_rows</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list_index_bound_rows</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
        <span class="c1"># Careful: list_index_bound_column_per_row</span>
        <span class="n">l_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">l_idx_pix</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="c1"># Check if we&#39;re not just looping over zero padding</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="ow">and</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Get the outer indexes of the (concatenated) spectra of the current row belonging to</span>
            <span class="c1"># the selection</span>
            <span class="n">idx_pix_1</span> <span class="o">=</span> <span class="n">convert_coor_to_spectrum_idx</span><span class="p">(</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="n">image_shape</span>
            <span class="p">)</span>
            <span class="n">idx_1</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix_1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">idx_pix_2</span> <span class="o">=</span> <span class="n">convert_coor_to_spectrum_idx</span><span class="p">(</span>
                <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">image_shape</span>
            <span class="p">)</span>
            <span class="n">idx_2</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix_2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Case we started or finished with empty pixel</span>
            <span class="k">if</span> <span class="n">idx_1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">idx_2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>

                <span class="c1"># Move forward until a non-empty pixel is found for idx_1</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">idx_1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">idx_1</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix_1</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">idx_pix_1</span> <span class="o">=</span> <span class="n">idx_pix_1</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>

                <span class="c1"># Move backward until a non-empty pixel is found for idx_2</span>
                <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="n">idx_2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">idx_2</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix_2</span> <span class="o">-</span> <span class="n">j</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">idx_pix_2</span> <span class="o">=</span> <span class="n">idx_pix_2</span> <span class="o">+</span> <span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="c1"># Check that we still have idx_2&gt;=idx_1</span>
            <span class="k">if</span> <span class="n">idx_1</span> <span class="o">&gt;</span> <span class="n">idx_2</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">size_array</span> <span class="o">+=</span> <span class="n">idx_2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">idx_1</span>
                <span class="n">l_idx</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">idx_1</span><span class="p">,</span> <span class="n">idx_2</span><span class="p">])</span>
                <span class="n">l_idx_pix</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">idx_pix_1</span><span class="p">,</span> <span class="n">idx_pix_2</span><span class="p">])</span>

        <span class="c1"># Add the couple of spectra indexes to the list</span>
        <span class="n">ll_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_idx</span><span class="p">)</span>
        <span class="n">ll_idx_pix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_idx_pix</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll_idx</span><span class="p">,</span> <span class="n">size_array</span><span class="p">,</span> <span class="n">ll_idx_pix</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.global_lipid_index_store" class="doc doc-heading">
<code class="highlight language-python"><span class="n">global_lipid_index_store</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">slice_index</span><span class="p">,</span> <span class="n">l_spectra</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function is used to extract the lipid label indexes for a given list of spectra, coming
from a given slice (slice_index).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>data</code></td>
          <td>
                <code>MaldiData</code>
          </td>
          <td><p>The object used to access the MALDI data.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>slice_index</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Index of the current slice.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>l_spectra</code></td>
          <td>
                <code>list(np.ndarray</code>
          </td>
          <td><p>A list of spectra (two dimensional numpy arrays), coming from
the slice having index slice_index.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>list</code></td>          <td>
                <code>list(str)</code>
          </td>
          <td><p>A list of list of lipid labels, one list per spectrum.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1327</span>
<span class="normal">1328</span>
<span class="normal">1329</span>
<span class="normal">1330</span>
<span class="normal">1331</span>
<span class="normal">1332</span>
<span class="normal">1333</span>
<span class="normal">1334</span>
<span class="normal">1335</span>
<span class="normal">1336</span>
<span class="normal">1337</span>
<span class="normal">1338</span>
<span class="normal">1339</span>
<span class="normal">1340</span>
<span class="normal">1341</span>
<span class="normal">1342</span>
<span class="normal">1343</span>
<span class="normal">1344</span>
<span class="normal">1345</span>
<span class="normal">1346</span>
<span class="normal">1347</span>
<span class="normal">1348</span>
<span class="normal">1349</span>
<span class="normal">1350</span>
<span class="normal">1351</span>
<span class="normal">1352</span>
<span class="normal">1353</span>
<span class="normal">1354</span>
<span class="normal">1355</span>
<span class="normal">1356</span>
<span class="normal">1357</span>
<span class="normal">1358</span>
<span class="normal">1359</span>
<span class="normal">1360</span>
<span class="normal">1361</span>
<span class="normal">1362</span>
<span class="normal">1363</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span> <span class="nf">global_lipid_index_store</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">slice_index</span><span class="p">,</span> <span class="n">l_spectra</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function is used to extract the lipid label indexes for a given list of spectra, coming</span>
<span class="sd">    from a given slice (slice_index).</span>

<span class="sd">    Args:</span>
<span class="sd">        data (MaldiData): The object used to access the MALDI data.</span>
<span class="sd">        slice_index (int): Index of the current slice.</span>
<span class="sd">        l_spectra (list(np.ndarray)): A list of spectra (two dimensional numpy arrays), coming from</span>
<span class="sd">            the slice having index slice_index.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list(list(str)): A list of list of lipid labels, one list per spectrum.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting computing ll_idx_labels&quot;</span><span class="p">)</span>
    <span class="n">ll_idx_labels</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">spectrum</span> <span class="ow">in</span> <span class="n">l_spectra</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get the average spectrum and add it to m/z plot</span>
            <span class="n">grah_scattergl_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>

            <span class="c1"># Get df for current slice</span>
            <span class="n">df_names</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">()[</span><span class="n">data</span><span class="o">.</span><span class="n">get_annotations</span><span class="p">()[</span><span class="s2">&quot;slice&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">slice_index</span><span class="p">]</span>

            <span class="c1"># Extract lipid names</span>
            <span class="n">l_idx_labels</span> <span class="o">=</span> <span class="n">return_index_labels</span><span class="p">(</span>
                <span class="n">df_names</span><span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                <span class="n">df_names</span><span class="p">[</span><span class="s2">&quot;max&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span>
                <span class="n">grah_scattergl_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l_idx_labels</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Save in a list of lists</span>
        <span class="n">ll_idx_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Returning ll_idx_labels&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ll_idx_labels</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.reduce_resolution_sorted" class="doc doc-heading">
<code class="highlight language-python"><span class="n">reduce_resolution_sorted</span><span class="p">(</span><span class="n">mz</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">max_intensity</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function function has been imported from the mspec module. Please consult the
corresponding module to get the docstring.</p>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1429</span>
<span class="normal">1430</span>
<span class="normal">1431</span>
<span class="normal">1432</span>
<span class="normal">1433</span>
<span class="normal">1434</span>
<span class="normal">1435</span>
<span class="normal">1436</span>
<span class="normal">1437</span>
<span class="normal">1438</span>
<span class="normal">1439</span>
<span class="normal">1440</span>
<span class="normal">1441</span>
<span class="normal">1442</span>
<span class="normal">1443</span>
<span class="normal">1444</span>
<span class="normal">1445</span>
<span class="normal">1446</span>
<span class="normal">1447</span>
<span class="normal">1448</span>
<span class="normal">1449</span>
<span class="normal">1450</span>
<span class="normal">1451</span>
<span class="normal">1452</span>
<span class="normal">1453</span>
<span class="normal">1454</span>
<span class="normal">1455</span>
<span class="normal">1456</span>
<span class="normal">1457</span>
<span class="normal">1458</span>
<span class="normal">1459</span>
<span class="normal">1460</span>
<span class="normal">1461</span>
<span class="normal">1462</span>
<span class="normal">1463</span>
<span class="normal">1464</span>
<span class="normal">1465</span>
<span class="normal">1466</span>
<span class="normal">1467</span>
<span class="normal">1468</span>
<span class="normal">1469</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">reduce_resolution_sorted</span><span class="p">(</span>
    <span class="n">mz</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">intensity</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">resolution</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">max_intensity</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;This function function has been imported from the mspec module. Please consult the</span>
<span class="sd">    corresponding module to get the docstring.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># First just count the unique values and store them to avoid recalc</span>
    <span class="n">current_mz</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">approx_mz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">mz</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mz</span><span class="p">)):</span>
        <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">resolution</span><span class="p">)</span> <span class="o">*</span> <span class="n">resolution</span>
        <span class="k">if</span> <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">current_mz</span><span class="p">:</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current_mz</span> <span class="o">=</span> <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="n">new_mz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
    <span class="n">new_intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">cnt</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>

    <span class="n">current_mz</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
    <span class="n">rix</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mz</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">current_mz</span><span class="p">:</span>
            <span class="n">rix</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">new_mz</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="o">=</span> <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">new_intensity</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">current_mz</span> <span class="o">=</span> <span class="n">approx_mz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># retrieve the maximum intensity value within the new bin</span>
            <span class="k">if</span> <span class="n">max_intensity</span><span class="p">:</span>
                <span class="c1"># check that the new intensity is greater than what is already there</span>
                <span class="k">if</span> <span class="n">intensity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">new_intensity</span><span class="p">[</span><span class="n">rix</span><span class="p">]:</span>
                    <span class="n">new_intensity</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="o">=</span> <span class="n">intensity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># sum the intensity values within the new bin</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_intensity</span><span class="p">[</span><span class="n">rix</span><span class="p">]</span> <span class="o">+=</span> <span class="n">intensity</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">new_mz</span><span class="p">,</span> <span class="n">new_intensity</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.reduce_resolution_sorted_array_spectra" class="doc doc-heading">
<code class="highlight language-python"><span class="n">reduce_resolution_sorted_array_spectra</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Recompute a sparce representation of the spectrum at a lower (fixed) resolution, summing over
    the redundant bins. Resolution should be &lt;=10**-4 as it's about the maximum precision
    allowed by float32.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>resolution</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>The size of the bin used to merge intensities. Defaults
to 10**-3.</p></td>
          <td>
                <code>10 ** -3</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>Array of shape=(2, m) similar to the input array but with a new sampling
resolution.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">833</span>
<span class="normal">834</span>
<span class="normal">835</span>
<span class="normal">836</span>
<span class="normal">837</span>
<span class="normal">838</span>
<span class="normal">839</span>
<span class="normal">840</span>
<span class="normal">841</span>
<span class="normal">842</span>
<span class="normal">843</span>
<span class="normal">844</span>
<span class="normal">845</span>
<span class="normal">846</span>
<span class="normal">847</span>
<span class="normal">848</span>
<span class="normal">849</span>
<span class="normal">850</span>
<span class="normal">851</span>
<span class="normal">852</span>
<span class="normal">853</span>
<span class="normal">854</span>
<span class="normal">855</span>
<span class="normal">856</span>
<span class="normal">857</span>
<span class="normal">858</span>
<span class="normal">859</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">reduce_resolution_sorted_array_spectra</span><span class="p">(</span><span class="n">array_spectra</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Recompute a sparce representation of the spectrum at a lower (fixed) resolution, summing over</span>
<span class="sd">        the redundant bins. Resolution should be &lt;=10**-4 as it&#39;s about the maximum precision</span>
<span class="sd">        allowed by float32.</span>

<span class="sd">    Args:</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        resolution (float, optional): The size of the bin used to merge intensities. Defaults</span>
<span class="sd">            to 10**-3.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (np.ndarray): Array of shape=(2, m) similar to the input array but with a new sampling</span>
<span class="sd">            resolution.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the re-sampled m/z and intensities from mspec library, with max_intensity = False to sum</span>
    <span class="c1"># over redundant bins</span>
    <span class="n">new_mz</span><span class="p">,</span> <span class="n">new_intensity</span> <span class="o">=</span> <span class="n">reduce_resolution_sorted</span><span class="p">(</span>
        <span class="n">array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">resolution</span><span class="p">,</span> <span class="n">max_intensity</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>

    <span class="c1"># Build a new array as the stack of the two others</span>
    <span class="n">new_array_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="n">new_mz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_mz</span>
    <span class="n">new_array_spectra</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">new_intensity</span>
    <span class="k">return</span> <span class="n">new_array_spectra</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.return_idx_inf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">return_idx_inf</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns the indices of the lipids that do not have an annotation</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>l_idx_labels</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1-dimensional array containing the indices of the lipid labels.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: A list containing the indices of the lipids that do not have an annotation.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1272</span>
<span class="normal">1273</span>
<span class="normal">1274</span>
<span class="normal">1275</span>
<span class="normal">1276</span>
<span class="normal">1277</span>
<span class="normal">1278</span>
<span class="normal">1279</span>
<span class="normal">1280</span>
<span class="normal">1281</span>
<span class="normal">1282</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">return_idx_inf</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the indices of the lipids that do not have an annotation</span>

<span class="sd">    Args:</span>
<span class="sd">        l_idx_labels (np.ndarray): A 1-dimensional array containing the indices of the lipid labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A list containing the indices of the lipids that do not have an annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.return_idx_sup" class="doc doc-heading">
<code class="highlight language-python"><span class="n">return_idx_sup</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>Returns the indices of the lipids that have an annotation</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>l_idx_labels</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A 1-dimensional array containing the indices of the lipid labels.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: A list containing the indices of the lipids that have an annotation.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1259</span>
<span class="normal">1260</span>
<span class="normal">1261</span>
<span class="normal">1262</span>
<span class="normal">1263</span>
<span class="normal">1264</span>
<span class="normal">1265</span>
<span class="normal">1266</span>
<span class="normal">1267</span>
<span class="normal">1268</span>
<span class="normal">1269</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">return_idx_sup</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the indices of the lipids that have an annotation</span>

<span class="sd">    Args:</span>
<span class="sd">        l_idx_labels (np.ndarray): A 1-dimensional array containing the indices of the lipid labels.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A list containing the indices of the lipids that have an annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">l_idx_labels</span><span class="p">)</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.return_index_labels" class="doc doc-heading">
<code class="highlight language-python"><span class="n">return_index_labels</span><span class="p">(</span><span class="n">l_min</span><span class="p">,</span> <span class="n">l_max</span><span class="p">,</span> <span class="n">l_mz</span><span class="p">,</span> <span class="n">zero_padding_extra</span><span class="o">=</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">**</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function returns the corresponding lipid name indices from a list of m/z values. Note
that the zero_padding_extra parameter is needed for both taking into account the zero-padding
(this way zeros on the sides of the peak are also identified as the annotated lipid) but also
because the annotation is very stringent in the first place, and sometimes border of the peaks
are missing in the annotation.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>l_min</code></td>
          <td>
                <code>list(int</code>
          </td>
          <td><p>This list provides the lower peak boundaries of the identified lipids.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>l_max</code></td>
          <td>
                <code>list(int</code>
          </td>
          <td><p>This list provides the upper peak boundaries of the identified lipids.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>l_mz</code></td>
          <td>
                <code>list(float</code>
          </td>
          <td><p>The list of m/z value which must be annotated with lipid names.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>zero_padding_extra</code></td>
          <td>
                <code>float</code>
          </td>
          <td><p>Size of the zero-padding. Defaults to 5<em>10</em>*-5.</p></td>
          <td>
                <code>5 * 10 ** -5</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: A 1-dimensional array containing the indices of the lipid labels.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1215</span>
<span class="normal">1216</span>
<span class="normal">1217</span>
<span class="normal">1218</span>
<span class="normal">1219</span>
<span class="normal">1220</span>
<span class="normal">1221</span>
<span class="normal">1222</span>
<span class="normal">1223</span>
<span class="normal">1224</span>
<span class="normal">1225</span>
<span class="normal">1226</span>
<span class="normal">1227</span>
<span class="normal">1228</span>
<span class="normal">1229</span>
<span class="normal">1230</span>
<span class="normal">1231</span>
<span class="normal">1232</span>
<span class="normal">1233</span>
<span class="normal">1234</span>
<span class="normal">1235</span>
<span class="normal">1236</span>
<span class="normal">1237</span>
<span class="normal">1238</span>
<span class="normal">1239</span>
<span class="normal">1240</span>
<span class="normal">1241</span>
<span class="normal">1242</span>
<span class="normal">1243</span>
<span class="normal">1244</span>
<span class="normal">1245</span>
<span class="normal">1246</span>
<span class="normal">1247</span>
<span class="normal">1248</span>
<span class="normal">1249</span>
<span class="normal">1250</span>
<span class="normal">1251</span>
<span class="normal">1252</span>
<span class="normal">1253</span>
<span class="normal">1254</span>
<span class="normal">1255</span>
<span class="normal">1256</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">return_index_labels</span><span class="p">(</span><span class="n">l_min</span><span class="p">,</span> <span class="n">l_max</span><span class="p">,</span> <span class="n">l_mz</span><span class="p">,</span> <span class="n">zero_padding_extra</span><span class="o">=</span><span class="mi">5</span> <span class="o">*</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">5</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function returns the corresponding lipid name indices from a list of m/z values. Note</span>
<span class="sd">    that the zero_padding_extra parameter is needed for both taking into account the zero-padding</span>
<span class="sd">    (this way zeros on the sides of the peak are also identified as the annotated lipid) but also</span>
<span class="sd">    because the annotation is very stringent in the first place, and sometimes border of the peaks</span>
<span class="sd">    are missing in the annotation.</span>

<span class="sd">    Args:</span>
<span class="sd">        l_min (list(int)): This list provides the lower peak boundaries of the identified lipids.</span>
<span class="sd">        l_max (list(int)): This list provides the upper peak boundaries of the identified lipids.</span>
<span class="sd">        l_mz (list(float)): The list of m/z value which must be annotated with lipid names.</span>
<span class="sd">        zero_padding_extra (float, optional): Size of the zero-padding. Defaults to 5*10**-5.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: A 1-dimensional array containing the indices of the lipid labels.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build empty array for lipid indexes</span>
    <span class="n">array_indexes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">l_mz</span><span class="p">),),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
    <span class="n">array_indexes</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idx_lipid</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">idx_mz</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">idx_lipid</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_min</span><span class="p">)</span> <span class="ow">and</span> <span class="n">idx_mz</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">l_mz</span><span class="p">):</span>

        <span class="c1"># Case peak is in lipid boundaries</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">l_mz</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">l_min</span><span class="p">[</span><span class="n">idx_lipid</span><span class="p">]</span> <span class="o">-</span> <span class="n">zero_padding_extra</span>
            <span class="ow">and</span> <span class="n">l_mz</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l_max</span><span class="p">[</span><span class="n">idx_lipid</span><span class="p">]</span> <span class="o">+</span> <span class="n">zero_padding_extra</span>
        <span class="p">):</span>
            <span class="n">array_indexes</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx_lipid</span>
            <span class="n">idx_mz</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Case peak is before lipid boundaries</span>
        <span class="k">elif</span> <span class="n">l_mz</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">l_min</span><span class="p">[</span><span class="n">idx_lipid</span><span class="p">]</span> <span class="o">-</span> <span class="n">zero_padding_extra</span><span class="p">:</span>
            <span class="c1"># array_indexes[idx_mz] = -1</span>
            <span class="n">idx_mz</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Case peak is after lipid boundaries</span>
        <span class="k">elif</span> <span class="n">l_mz</span><span class="p">[</span><span class="n">idx_mz</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">l_max</span><span class="p">[</span><span class="n">idx_lipid</span><span class="p">]</span> <span class="o">+</span> <span class="n">zero_padding_extra</span><span class="p">:</span>
            <span class="n">idx_lipid</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">array_indexes</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.return_spectrum_per_pixel" class="doc doc-heading">
<code class="highlight language-python"><span class="n">return_spectrum_per_pixel</span><span class="p">(</span><span class="n">idx_pix</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function returns the spectrum of the pixel having index pixel_idx, using the lookup
table array_pixel_indexes.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>idx_pix</code></td>
          <td>
                <code>int</code>
          </td>
          <td><p>Index of the pixel to return.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_spectra</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum
data (m/z and intensity) for each pixel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>array_pixel_indexes</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (m,2) containing the boundary indices of
each pixel in array_spectra.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: An array of shape (2,m) containing spectrum data (m/z and intensity) for the
requested pixel.</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">705</span>
<span class="normal">706</span>
<span class="normal">707</span>
<span class="normal">708</span>
<span class="normal">709</span>
<span class="normal">710</span>
<span class="normal">711</span>
<span class="normal">712</span>
<span class="normal">713</span>
<span class="normal">714</span>
<span class="normal">715</span>
<span class="normal">716</span>
<span class="normal">717</span>
<span class="normal">718</span>
<span class="normal">719</span>
<span class="normal">720</span>
<span class="normal">721</span>
<span class="normal">722</span>
<span class="normal">723</span>
<span class="normal">724</span>
<span class="normal">725</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">return_spectrum_per_pixel</span><span class="p">(</span><span class="n">idx_pix</span><span class="p">,</span> <span class="n">array_spectra</span><span class="p">,</span> <span class="n">array_pixel_indexes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function returns the spectrum of the pixel having index pixel_idx, using the lookup</span>
<span class="sd">    table array_pixel_indexes.</span>

<span class="sd">    Args:</span>
<span class="sd">        idx_pix (int): Index of the pixel to return.</span>
<span class="sd">        array_spectra (np.ndarray): An array of shape (2,n) containing spectrum</span>
<span class="sd">            data (m/z and intensity) for each pixel.</span>
<span class="sd">        array_pixel_indexes (np.ndarray): An array of shape (m,2) containing the boundary indices of</span>
<span class="sd">            each pixel in array_spectra.</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: An array of shape (2,m) containing spectrum data (m/z and intensity) for the</span>
<span class="sd">            requested pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get the indices of the spectrum of the requested pixel</span>
    <span class="n">idx_1</span><span class="p">,</span> <span class="n">idx_2</span> <span class="o">=</span> <span class="n">array_pixel_indexes</span><span class="p">[</span><span class="n">idx_pix</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">idx_1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">idx_2</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span>  <span class="c1"># To return empty list in the end</span>
    <span class="k">return</span> <span class="n">array_spectra</span><span class="p">[:,</span> <span class="n">idx_1</span> <span class="p">:</span> <span class="n">idx_2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.sample_rows_from_path" class="doc doc-heading">
<code class="highlight language-python"><span class="n">sample_rows_from_path</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function takes a path as input and returns the lower and upper indexes of the rows
belonging to the current selection (i.e. indexed in the path), as well as the corresponding
column boundaries for each row. Note that, although counter-intuitive given the kind of
regression done in this function, x is the vertical axis (from top to bottom), and y the
horizontal one.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>path</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>A two-dimensional array, containing, in each row, the row and column</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span>, <span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>The first array contains the lower and upper indexes of the rows</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>belonging to the current selection. The second array contains, for each row, the</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>corresponding column boundaries (there can be more than 2 for non-convex shapes).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1118</span>
<span class="normal">1119</span>
<span class="normal">1120</span>
<span class="normal">1121</span>
<span class="normal">1122</span>
<span class="normal">1123</span>
<span class="normal">1124</span>
<span class="normal">1125</span>
<span class="normal">1126</span>
<span class="normal">1127</span>
<span class="normal">1128</span>
<span class="normal">1129</span>
<span class="normal">1130</span>
<span class="normal">1131</span>
<span class="normal">1132</span>
<span class="normal">1133</span>
<span class="normal">1134</span>
<span class="normal">1135</span>
<span class="normal">1136</span>
<span class="normal">1137</span>
<span class="normal">1138</span>
<span class="normal">1139</span>
<span class="normal">1140</span>
<span class="normal">1141</span>
<span class="normal">1142</span>
<span class="normal">1143</span>
<span class="normal">1144</span>
<span class="normal">1145</span>
<span class="normal">1146</span>
<span class="normal">1147</span>
<span class="normal">1148</span>
<span class="normal">1149</span>
<span class="normal">1150</span>
<span class="normal">1151</span>
<span class="normal">1152</span>
<span class="normal">1153</span>
<span class="normal">1154</span>
<span class="normal">1155</span>
<span class="normal">1156</span>
<span class="normal">1157</span>
<span class="normal">1158</span>
<span class="normal">1159</span>
<span class="normal">1160</span>
<span class="normal">1161</span>
<span class="normal">1162</span>
<span class="normal">1163</span>
<span class="normal">1164</span>
<span class="normal">1165</span>
<span class="normal">1166</span>
<span class="normal">1167</span>
<span class="normal">1168</span>
<span class="normal">1169</span>
<span class="normal">1170</span>
<span class="normal">1171</span>
<span class="normal">1172</span>
<span class="normal">1173</span>
<span class="normal">1174</span>
<span class="normal">1175</span>
<span class="normal">1176</span>
<span class="normal">1177</span>
<span class="normal">1178</span>
<span class="normal">1179</span>
<span class="normal">1180</span>
<span class="normal">1181</span>
<span class="normal">1182</span>
<span class="normal">1183</span>
<span class="normal">1184</span>
<span class="normal">1185</span>
<span class="normal">1186</span>
<span class="normal">1187</span>
<span class="normal">1188</span>
<span class="normal">1189</span>
<span class="normal">1190</span>
<span class="normal">1191</span>
<span class="normal">1192</span>
<span class="normal">1193</span>
<span class="normal">1194</span>
<span class="normal">1195</span>
<span class="normal">1196</span>
<span class="normal">1197</span>
<span class="normal">1198</span>
<span class="normal">1199</span>
<span class="normal">1200</span>
<span class="normal">1201</span>
<span class="normal">1202</span>
<span class="normal">1203</span>
<span class="normal">1204</span>
<span class="normal">1205</span>
<span class="normal">1206</span>
<span class="normal">1207</span>
<span class="normal">1208</span>
<span class="normal">1209</span>
<span class="normal">1210</span>
<span class="normal">1211</span>
<span class="normal">1212</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">sample_rows_from_path</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function takes a path as input and returns the lower and upper indexes of the rows</span>
<span class="sd">    belonging to the current selection (i.e. indexed in the path), as well as the corresponding</span>
<span class="sd">    column boundaries for each row. Note that, although counter-intuitive given the kind of</span>
<span class="sd">    regression done in this function, x is the vertical axis (from top to bottom), and y the</span>
<span class="sd">    horizontal one.</span>

<span class="sd">    Args:</span>
<span class="sd">        path (np.ndarray): A two-dimensional array, containing, in each row, the row and column</span>
<span class="sd">        coordinates (x and y) of the current selection.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (np.ndarray, np.ndarray): The first array contains the lower and upper indexes of the rows</span>
<span class="sd">        belonging to the current selection. The second array contains, for each row, the</span>
<span class="sd">        corresponding column boundaries (there can be more than 2 for non-convex shapes).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find out the lower and upper rows</span>
    <span class="n">x_min</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">x_max</span> <span class="o">=</span> <span class="n">path</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># Numba won&#39;t accept a list of list, so I must use a list of np arrays for the column boundaries</span>
    <span class="n">list_index_bound_column_per_row</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Also register the x-axis direction to correct the linear regression accordingly</span>
    <span class="n">dir_prev</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># For each couple of points in the path, do a linear regression to find the corresponding y</span>
    <span class="c1"># (needed due to non constant sampling on the y-axis)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">x2</span> <span class="o">!=</span> <span class="n">x1</span><span class="p">:</span>
            <span class="n">slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span>
            <span class="n">intercept</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">-</span> <span class="n">slope</span> <span class="o">*</span> <span class="n">x1</span>

            <span class="c1"># Compute if change of direction on the x-axis and correct accordingly</span>
            <span class="k">if</span> <span class="n">x2</span> <span class="o">&gt;=</span> <span class="n">x1</span><span class="p">:</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">dir</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">dir_prev</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">dir</span> <span class="o">==</span> <span class="n">dir_prev</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="nb">dir</span>
            <span class="n">dir_prev</span> <span class="o">=</span> <span class="nb">dir</span>

            <span class="c1"># For each x, get the corresponding y (with non constant sampling on y axis)</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x1</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="nb">dir</span><span class="p">):</span>
                <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">],</span> <span class="nb">round</span><span class="p">(</span><span class="n">slope</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">intercept</span><span class="p">)</span>
                <span class="p">)</span>

    <span class="c1"># Min x and max x often cover only zero or one pixel due to the way the sampling is done, we</span>
    <span class="c1"># just get rid of them</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">x_min</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">x_max</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="c1"># Clean list</span>
    <span class="n">l_to_del</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>

        <span class="c1"># If everything went fine, x should appear an even number of times</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># logging.warning(&quot;Bug with list x&quot;, x, list_index_bound_column_per_row[x - x_min])</span>
            <span class="c1"># Try to correct the number of times x appear</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span>
            <span class="p">):</span>
                <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_index_bound_column_per_row</span><span class="p">[</span>
                    <span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span>
                <span class="p">][:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">],</span>
                    <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
        <span class="n">list_index_bound_column_per_row</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="n">x_min</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>  <span class="c1"># Inplace sort to spare memory</span>

    <span class="c1"># Convert list of np.array to np array padded with zeros (for numba compatibility)</span>
    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">max</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">list_index_bound_column_per_row</span><span class="p">])</span>
    <span class="n">array_index_bound_column_per_row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
        <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">),</span> <span class="n">max_len</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">list_index_bound_column_per_row</span><span class="p">):</span>
        <span class="n">array_index_bound_column_per_row</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)]</span> <span class="o">=</span> <span class="n">arr</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x_min</span><span class="p">,</span> <span class="n">x_max</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="n">array_index_bound_column_per_row</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>

<div class="doc doc-object doc-function">



<h2 id="modules.tools.spectra.strip_zeros" class="doc doc-heading">
<code class="highlight language-python"><span class="n">strip_zeros</span><span class="p">(</span><span class="n">array</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents ">
  
      <p>This function strips a (potentially sparse) array (e.g. one that has been converted with
convert_array_to_fine_grained) from its columns having intensity zero.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>array</code></td>
          <td>
                <code><span title="numpy">np</span>.<span title="numpy.ndarray">ndarray</span></code>
          </td>
          <td><p>An array of shape (2,n) containing spectrum data (m/z
and intensity).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>np.ndarray: The same array stripped from its zero intensity values. Now of shape (2,m).</p></td>
        </tr>
    </tbody>
  </table>

      <details class="quote">
        <summary>Source code in <code>modules/tools/spectra.py</code></summary>
        <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@njit</span>
<span class="k">def</span> <span class="nf">strip_zeros</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This function strips a (potentially sparse) array (e.g. one that has been converted with</span>
<span class="sd">    convert_array_to_fine_grained) from its columns having intensity zero.</span>

<span class="sd">    Args:</span>
<span class="sd">        array (np.ndarray): An array of shape (2,n) containing spectrum data (m/z</span>
<span class="sd">            and intensity).</span>

<span class="sd">    Returns:</span>
<span class="sd">        np.ndarray: The same array stripped from its zero intensity values. Now of shape (2,m).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Look for the non-zero values and store them in l_to_keep</span>
    <span class="n">l_to_keep</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span> <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span>

    <span class="c1"># Keep only the previsouly assigned non-zero values</span>
    <span class="n">array_mz</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">l_to_keep</span><span class="p">)</span>
    <span class="n">array_intensity</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">l_to_keep</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">array_mz</span><span class="p">,</span> <span class="n">array_intensity</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
      </details>
  </div>

</div>



  </div>

  </div>

</div>

              
            </article>
            
          </div>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
    <nav class="md-footer__inner md-grid" aria-label="Footer" >
      
        
        <a href="../misc/" class="md-footer__link md-footer__link--prev" aria-label="Previous: Misc" rel="prev">
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
          </div>
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Previous
              </span>
              Misc
            </div>
          </div>
        </a>
      
      
        
        <a href="../volume/" class="md-footer__link md-footer__link--next" aria-label="Next: Volume" rel="next">
          <div class="md-footer__title">
            <div class="md-ellipsis">
              <span class="md-footer__direction">
                Next
              </span>
              Volume
            </div>
          </div>
          <div class="md-footer__button md-icon">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
          </div>
        </a>
      
    </nav>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": ["navigation.sections"], "search": "../../../assets/javascripts/workers/search.b97dbffb.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version.title": "Select version"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.6c7ad80a.min.js"></script>
      
    
  </body>
</html>